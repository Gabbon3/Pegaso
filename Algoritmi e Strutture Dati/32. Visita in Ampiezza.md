# 32. Visita in Ampiezza

## 1. Attraversamento: come esplorare un grafo

Il problema consiste nell'attraversare ogni nodo raggiungibile da un punto di partenza (chiamato __sorgente__ o __radice__) esattamente una volta:
- visita in ampiezza __BFS__ -> visiti i vicini immediati, poi i vicini dei vicini... ti espandi a macchia d'olio
- visita in profondita __DFS__ -> visiti un percorso alla volta andando fino in fondo ogni volta, se non va bene torni indietro e ricominci con un altro.

### Il problema del giro a vuoto: soluzione "Naive"

Se visitassimo un albero senza memoria cadremmo in un loop infinito, dobbiamo tenere traccia dei nodi n visitati, nei grafi i __cicli__ esistono! Quindi marchiamo ogni nodo n visitato con `visited`

## 2. Visita in ampiezza (BFS)

Anche qui come per gli alberi, useremo una coda FIFO __queue__ per sfruttare il meccanismo BFS:
1. la radice viene aggiunta alla coda `Q` e la segnamo come visitata:
2. finche la coda non è vuota:
    - `u = Q.dequeue()`
    - guardo i vicini, cioe i nodi adiacenti
    - se un vicino non è stato visitato quindi `vicino.visited == false`:
        - `vicino.visited = true`
        - `Q.enqueue(vicino)`

## 3. Numero di Erdos

Vedere PDF

## 4. Albero dei Cammini (BFS-Tree)

durante BFS si puo usare un array chiamato __parent__ per segnarci da dove siamo arrivati
- Alla fine otteniamo un __albero di copertura BFS__.
- Sarebbe un sottografo che collega tutti i nodi senza creare cicli e contiene i __cammini piu brevi__ dalla sorgente a ogni altro nodo

## Complessita e Analisi

BFS -> $O(n + m)$ perche per ogni nodo visitiamo ogni suo collegamento (quindi numero di nodi + numero di archi totali)

Per trovare il cammino piu efficiente bisogna partire dalla __destinazione__ fino alla __radice__ passando per ogni nodo padre e chiedendo il successivo.

in c++ conviene usare un array "parent" dove ogni indice è un nodo:

```c++
// qui diciamo che il padre del nodo 1 è il nodo 5
parent[1] = 5;
```