# 41. Programmazione dinamica - esempi

## Hateville

è un villaggio, composto da `n` case numerate da 1 ad `n` su una sola strada.

Ognuno odia i propri vicini, quindi:

- `x` odia `x - 1` ed `x + 1` se esistenti

Si vuole organizzare una sagra, ogni abitante $x$ ha intenzione di donare una quantità $D[x]$, ma non intende partecipare ad una raccolta fondi a cui partecipano uno o entrambi o propri vicini.

> Qual è la quantità massima di fondi che può essere raccolta?

Se $i$ è un vicino egli puo:

- fare la donazione
- non fare la donazione

- Se $i$ non fa la donazione allora $DP[i] = DP[i - 1]$ nel senso che se i non la fa allora la donazione sarà data dalle donazioni raccolte prima di lui quindi DP i - 1
- Se $i$ fa la donazione allora $DP[i] = D[i] + DP[i - 2]$

Come faccio a scegliere tra le due opzioni??
$$DP[i] = max(DP[i - 1], D[i] + DP[i - 2])$$

questo per $i \geq 2$

- i = 0 DP[i] = 0
- i = 1 DP[i] = D[1]

```c
int hateville(int[] D, int n) {
    int[n] DP = new int[n];
    DP[0] = 0
    DP[1] = D[1]
    for (int i = 2; i <= n; i++) {
        DP[i] = math.max(DP[i - 1], D[i] + DP[i - 2]);
    }
    return DP[n];
}
```

> ATTENZIONE! cosi non possiamo sapere quali vicini hanno donato con esattezza

```c
Set solution(int[] DP, int[] D, int i) {
    if i == 0
        return 0
    else if i == 1
        return {1}
    else if DP[i] == DP[i − 1]
        return solution(DP, D, i − 1)
    else
        Set sol = solution(DP, D, i − 2)
        sol.insert(i)
    return sol
}
```

### Complessita

Computazionale:
- $T(n)$ = $\theta (n)$

Temporale:
- $S(n)$ ? $\theta (n)$

---

## Problema dello zaino

> Problema di ottimizzazione:
- abbiamo uno zaino che supporta un certo peso con n oggetti, ognuno ha un peso e un "valore" di profitto (quanto ci teniamo a quell oggetto).
- In breve vogliamo sapere quali cose prendere e mettere nello zaino per avere il valore maggiore senza superare il limite

> L'input è il seguente:
- Vettore $w : w[i]$ è il peso weight dell'oggetto i-esimo
- Vettore $p : p[i]$ è il profitto (profit) dell'oggetto i-esimo
- La capacita C dello zaino

> L'output è un insieme $S \subseteq \{1,...,n\}$ tale che:
- il peso totale deve essere <= alla capacita
    - $w(S) = \sum_{i \in S} w[i] \leq C$ peso totale = sommatoria dei pesi per ogni oggetto di S tale che sia <= di C
- il profitto totale deve essere massimizzato:
    - $max(p(S) = \sum_{i \in S} p[i])$

