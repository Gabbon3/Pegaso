# 34. Ordinamento Topologico

## 1. Albero di copertura DF (Depth First)

L'albero DF viene costruito in modo che ogni nodo del grafo sia raggiungibile da un nodo radice dell'albero.

è chiamato albero di **copertura** perche copre tutti i nodi del grafo relativi alla componente connessa del medesimo.

Il termine **marcato** si riferisce ai nodi che sono stati visitati durante l esecuzione.

La visita **DFS** genera dunque l'albero dei cammini DFS:

- ogni arco incontrato viene:
    1. inserito nell'albero $T$ ed è chiamato **arco dell'albero**, gli archi $(u, v)$ **non inclusi** nell'albero si dividono in 3 categorie:
        1. arco in avanti -> se $u$ **antenato** di $v$ in $T(u, v)$
        2. arco all'indietro -> se $u$ **discentente** di $v$ in $T(u, v)$
        3. arco di attraversamento -> se $u$ e $v$ non possiede nessun legame di parentela allora sono due nodi facenti parte di due alberi diversi.

### Identificazione ciclo

Pagina 7 PDF

se ce un ciclo topologico quindi dove A ... D sono connessi tra loro identifichiamo il ciclo nel momento in cui $d(n)$ = x e $f(n)$ = 0 dove 0 è perche non siamo mai arrivati ad un nodo foglia e non siamo mai tornati indietro.

Ricordiamo che:

- $d(n)$ discovery time -> quando procedi e scopri
- $f(n)$ finish time -> quando hai finito di scoprire e torni indietro

```c++
// u e v sono due vertici, dove
/*
u = D
v = A
...
A -> B
|    |
D <- C
*/
if (d[u] > d[v] && f[v] == 0)
// quindi se discovery di D > discovery di A e finish time di A == 0
```

## 3. Ordinamento Topologico

Dato un grafo diretto e aciclico $G = (V, E)$ un **ordinamento topologico**
è un ordinamento lineare dei suoi nodi tale che se $(u, v) \in E$ per ogni nodo quindi va da $u$ a $v$ ($u \to v$) il nodo $u$ deve apparire prima di $v$.

In altre parole ogni nodo puo andare solo in avanti, _vedere PDF a pagina 9_.

Se volessimo scrivere un algoritmo naive per individuare un grafo topologico dovremmo:

- trovare un nodo senza archi entranti
- aggiungere questo nodo nell'ordinamento e rimuoverlo insieme a tutti i suoi archi, continuare...

In sostanza pusho nello stack solo se sono in finish time

## 4. Componenti connesse

### Raggiungibilità

Semplicemente in base alle connessioni se un nodo è raggiungibile da un altro

si noti come nei grafi non orientati sia piu semplice ottenere maggiore raggiungibilità

## IMPORTANTE: Sottografi e Connessioni

**Digrafo** -> grafo connesso con cammini unidirezionali

**Grafo Connesso** -> 
- un grafo è connesso se e solo se esiste un cammino da ogni **vertice V (nodo)** **ad ogni altro vertice**
- un grafo è connesso se al termine della DFS tutti i nodi sono stati marcati, altrimenti una singola passata NON è sufficiente e la visita deve ripartire da un nodo non marcato, scoprendo una nuova porzione del grafo.

ci colleghiamo anche ad un altra definizione importante il __sottografo__

**Sottografo** -> è un grafo che è racchiuso dentro un altro grafo, matematicamente parlando si intende un sottografo $G'$ cosi: $G' \subseteq G$ dove ovviamente abbiamo sia vertici che archi inclusi anchessi come G quindi $V' \subseteq V$ - $E' \subseteq E$

unendo le due questioni possiamo notare che nei grafi possono esistere dei **sottografi fortemente connessi** quindi possiamo identificare delle parti di grafo che sono molto connesse tra loro, possiamo anche avere sottografi composti da singoli nodi.
Guardare pagina 18 del PDF