# 27. Albero di ricerca binaria

Un albero diventa BST (Binary Search Tree) SE e solo SE:
- tutti i nodi del sottoalbero sinistro sono $<$ della radice
- tutti i nodi del sottoalbero destro sono $>$ della radice
- nessun duplicato

## 2. Perche farlo (Lookup)

Effettui una ricerca binaria in automatico

Cerchi `X`:
- se `X == Radice` trovato! se no:
- se `X < Radice` vai a sinistra
- se `X > Radice` vai a destra

per ogni passo dimezzi la ricerca, proprio come avviene nella ricerca binaria negli array ordinati.

## 3. Complessita e Bilanciamento

- Caso __Ottimo__: l'albero è bilanciato, altezza $log_2 N$ ricerca velocissima: $O(log N)$
- Caso __Pessimo__: l'albero degenera in una linea continua (1, 2, 3, 4, 5...) Altezza $N$ Complessita $O(N)$

## 4. Superpotere visita In-Order

Se visiti l'albero __in-order__ quindi:
1. sinistra
2. radice
3. destra

ottieni gli elementi in ordine crescente in maniera naturale

## 5. Recursion King

la ricerca ricorsiva è super naturale e necessita di pochissime righe di codice:

```c
struct node* search(node* root, int key) {
    if (root == NULL || root->data == key) return root; // Base
    if (key < root->data) return search(root->left, key); // Sinistra
    else return search(root->right, key); // Destra
}
```

