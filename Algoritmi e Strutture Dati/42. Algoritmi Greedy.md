# 42. Algoritmi Greedy

### Conversione da decimale a binario

13:
- $2^3 = 8$
- $2^2 = 4$
- $2^1 = 2$ ma 2 + 4 != 5
- $2^0 = 1$

$= 13$

Gli algoritmi golosi non portano alla soluzione ottimale ma spesso __subottimale__

### Paragone con Programmazione Dinamica

- __Obiettivo__: entrambe le tecniche si usano per risolvere problemi di _ottimizzazione_
- __Approccio__:
    - _goloso_: procediamo secondo decisioni localmente ottimali senza considerare le conseguenze a lungo termine
    - _dinamico_: divide et impera
- __Scelte__:
    - _goloso_: soluzione che sembra migliore subito
    - _dinamico_: si guardano tutte le soluzioni alla ricerca della migliore
- __Complessita__:
    - _goloso_: dipende dalle decisioni prese di ogni passaggio
    - _dinamico_: dipende dalla complessita della soluzione scelta

## 2. Insieme Indipendente Massimale

Sia $S = { 1, 2, ..., n }$ un insieme di intervalli della retta in $\mathbb{R}$

Ogni intervallo $[a_i, b_i[$, con $i \in S$ è chiuso a sinistra e aperto a destra

- $a_i$ tempo di inizio
- $b_i$ tempo di fine

| i | $a_i$ | $b_i$ |
| --- | --- | --- |
| __1__ | 1 | 4 |
| __2__ | 3 | 5 |
| __3__ | 0 | 6 |
| __4__ | 5 | 7 |
| __5__ | 3 | 8 |
| __6__ | 5 | 9 |
| __7__ | 6 | 10 |
| __8__ | 8 | 11 |
| __9__ | 8 | 12 |
| __10__ | 2 | 13 |
| __11__ | 12 | 14 |

Ordiniamo per `b` (tempo di fine)

Usiamo un `Set`

- __Complessita__: 
    - $O (n log n)$ input non ordinato
    - $O (n)$ input ordinato

- __In Breve__:
    1. Scegliere sempre l'attività che __finisce prima__ (che ha il tempo di fine <)
    2. Scartare tutte quelle che si sovrappongono ad esso
    3. Ripetere con quelle rimaste

## 3. Problema del Resto

dato un insieme di "tagli di monete" (1 cent, 2 cent, 5 cent...)

abbiamo $R$ il resto da restituire

- __Complessita__: 
    - $O (n log n)$ input non ordinato
    - $O (n)$ input ordinato