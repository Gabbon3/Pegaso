# 2. Dividi et Impera

## 2. Tecniche di progetto

### 1. Dividi et impera

- funzionamento -> suddividi il problema in tanti sottoproblemi indipendenti e semplici.
- approccio -> top down
- utilizzo -> problemi di decisione o ricerca

### 2. Programmazione dinamica

- funzionamento -> la soluzione si ottiene partendo da tanti sottoproblemi che possono ripetersi
- approccio -> bottom up
- utilizzo -> problemi di ottimizzazione

### 3. Memoization (annotazione)

- funzionamento -> si usa una cache per salvare i risultati di operazioni costose
- approccio -> top down
- utilizzo -> problemi di ottimizzazione

### 4. Tecnica Greedy

- funzionamento -> si basa su scelte immediate non lungimiranti, si sceglie l operazione che localmente sembra apparentemente buona
- approccio -> top down
- utilizzo -> selezione sotto insieme di elementi che verificano certe proprieta

### 5. Backtrack

- funzionamento -> si va a tentativi
- approccio -> tentativi
- utilizzo -> algoritmi di visita e strutture dati

### 6. Algoritmi probabilistici

- funzionamento -> invece di fare una scelta costosa basata su giudizio iniziale si sceglie il caso gratuitamente applicando il calcolo delle probabilita
- tipologie ->
    - montecarlo: correttezza probabilistica
    - las vegas: corretti nel risultato ma con tempo di esecuzione probabilistico

## 3. Dividi et Impera

come detto Ã¨ top down e suddividi i problemi in problemi piu piccoli.
puoi parallelizzare la computazione.

### 3 fasi dell algoritmo

1. divide -> dividi il problema principale in sottoproblemi
2. impera -> i sottoproblemi sono risolti ricorsivamente
3. combina -> ricombini l output delle chiamate ricorsive per costruire il risultato finale

### differenze nell applicazione

non esiste una ricetta universale.
- merge sort -> ha una fase di _divide_ semplice ma una fase di _combina_ complessa.
- quick sort -> l esatto opposto.

## 4. Torre di hanoi

