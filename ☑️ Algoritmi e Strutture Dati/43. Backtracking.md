# 43. Backtracking

> "Prova a fare qualcosa, se non va bene lo disfo e provo qualcosaltro"

> "Ritenta, e sarai piu fortunato"

## 1. Introduzione

**Brute Force**: tento tutte le strade percorribili

## 2. Gioco del 15

Griglia $4 \times 4$ con 15 caselle numerate e una vuota, bisogna ordinare le piastrelle utilizzando il minor numero di mosse possibili.

Possiamo usare brute force ma ci sono troppe combinazioni **16!** modi per poter disporre le piastrelle

> Solo la metà delle permutazioni è raggiungibile da una configurazione valida

**Parità di una permutazione**: numero di inversioni in essa, cioè quando scambiamo due numeri nel momento in cui uno **piu grande** precede uno **piu piccolo** come ad esempio 3, 2 - 4, 1

### Comprensione

1. Prendiamo la griglia e linearizziamola, quindi:

```
 1  2  3  4
 5  6  7  8
 9 10 11 12
13 15 14  0  
```

La lista quindi è: `1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 15, 14` (ignoriamo la cella vuota 0)

2. Calcoliamo le **Inversioni** $I$ come descritto in precedenza, quindi:
    - da 1 a 13 non ci sono inversioni poiche ogni numero successivo è piu grande del precedente
    - arriviamo a `15, 14` è un _inversione_ poiche 15 > 14, quindi $I = 1$

3. Calcoliamo la distanza $R$ della cella vuota partendo _dal basso_:
    - nel nostro caso la cella vuota è l'ultima quindi $R = 0$

4. **Per capire se la griglia è risolvibile**: $I + R$ ->
    - pari? la griglia è risolvibile
    - dispari? la griglia NON è risolvibile

Nel nostro caso $R + I = 0 + 1 = 1$ la griglia non è risolvibile

### 3. Come risolvere la griglia

### Albero degli stati

Ogni configurazione puo essere rappresentata come un albero, ogni mossa genera un nuovo albero, in breve avremmo un albero enorme.

**Soluzione**: potare i rami secchi, quindi le strade che non portano alla soluzione o che ci allontanano troppo.ù

### La funzione di costo $c(x)$

Per decidere quale ramo seguire utilizziamo un algoritmo per calcolare il costo di ogni griglia.

$$c(x) = g(x) + h(x)$$

dove:
- $g(x)$ il passato -> è il numero di mosse che abbiamo fatto fino ad ora per arrivare a quella griglia
    - piu è alto piu stiamo _faticando_
- $h(x)$ il futuro/euristica -> è una **stima** di quante mosse mancano per finire

### La Bussola: distanza di Manhattan $h(x)$

Invece di calcolare la distanza in linea d'aria (**euclidea**) calcoliamo quanti passi (orizzontali + verticali) ogni singola piastrella deve fare per arrivare al suo posto giusto

**Esempio**:

la tessera `1` si trova in `2, 2` ma dovrebbe essere in `0, 0`
- distanza orizzontale: $|2 - 0| = 2$ passi
- distanza verticale: $|2 - 0| = 2$ passi
- _Distanza di Manhattan_ per la tessera `1` = $2 + 2 = 4$

Facendo questo calcolo per tutte le tessere e sommando i risultati otteniamo $h(x)$

### Conclusione gioco del 15

Utilizziamo $h(x)$ per aiutare il backtracking a scegliere le mosse

Ecco le regole principali:

- **Branch and Bound**: se trovi una strada che ha un $h(x)$ troppo alto rispetto ad una soluzione gia trovata, _elimini quel ramo_ e non esplori piu.

## 3. Il problema delle 8 Regine

### 1. Intruduzione

Bisogna posizionarle tutte in maniera che nessuna possa mangiarne un altra. 
Ne deriva che non ci possono mai essere due regine nella stessa:
- Riga ↔️
- Colonna ↕️
- Diagonale ↗️↘️

**Movimento**: Ci spostiamo di colonna in colonna ogni volta, non iteriamo con un doppio for (non avrebbe senso)

### 2. Perché non andare a caso? (Brute Force vs Backtracking)

ci sarebbero troppe combinazioni andando a brute force, sono $8 x 8$ celle quindi $64!$ combinazioni

### 3. Backtracking

1. metti la prima regina nella prima casella
2. per ogni colonna successiva cerchi quella sicura
    - se non esiste torni indietro con il backtracking
3. se non esiste la cella sicura quindi sappiamo che la configurazione precedente non va bene quindi
    - sposti la precedente regina nella successiva cella disponibile e cosi via

### `is_safe`

in breve verifica se una cella è sicura controllando in tutte le direzioni della regina se ce ne sono altre
controlla pero solo le regine **alla sua sinistra**

## 4. Sudoku

**NOTA IMPORTANTE**: il sudoku con il backtracking ce la fa tranquillamente per la maggior parte dei sudoku, ma per quelli estramamente complessi impiegherebbe una vita, in questo senso si utilizzano algoritmi ancora piu complessi che sfruttano _euristiche_ per scegliere non celle a caso ma celle con piu probabilita di essere valide