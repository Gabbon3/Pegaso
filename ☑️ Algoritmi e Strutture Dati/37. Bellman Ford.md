# 37. Bellman Ford

## Quale algoritmo scegliere in base al grafo

| Peso | Grafo | Algoritmo | Complessita | Descrizione |
| --- | --- | --- | --- | --- |
| $+$ | DAG ~ Diretto Aciclico | shortestPathDAG | $O(n + m)$ | ... |
| $+$ | Denso | Dijkstra | $O(n^2)$ | tanti archi? |
| $+$ | Sparso | Johnson | $O(m \times log_2 n)$ | pochi archi? |
| $-$ | Qualsiasi | Bellman Ford | $O(n \times m)$ | pesi negativi? |

## Funzionamento algoritmo

1. **Situazione iniziale**:
    - la partenza $S$ ha costo 0
    - tutti gli altri nodi hanno costo $\infty$
2. **Rilassamento**
    - questa operazione viene ripetuta fino alla nausea:
        1. prende una strada che va da __A__ a __B__ e costa __5__
        2. se arrivo ad A e poi prendo questa strada per B spendo meno di quanto memorizzato attualmente?
            - SI -> sostituisco il nuovo valore
            - NO -> ignoro
3. **Il Ciclo**
    - Bellman Ford fa questo controllo su __tutte le strade del grafo__ e non lo fa solo una volta ma piu volte.
    - Quante volte? $N - 1$ (dove $N$ corrisponde al numero totale di nodi)
    - __Perche__? In questo modo siamo certi di esplorare tutto e di garantire matematicamente che il cammino sia effettivamente quello piu breve.
4. **Ruolo dei pesi negativi**
    - Perche usare questo algoritmo lento anziché Dijkstra? Poiche grazie al fatto che possiamo gestire i pesi negativi e controlliamo piu volte le strade ad ogni iterazione, potremmo ad esempio scoprire che un cammino che inizialmente sembrava costare tanto (es. da __A a B costa 100__) in realta costa poco poiche successivamente ad esso ce un peso negativo (es. da __B a C costa -80__ che sarebbe un affare). Dijkstra vedendo inizialmente 100 lo avrebbe scartato a priori perche non è pensato per affondare bene tutti i cammini, è piu superficiale e diretto.
5. **Controllo finale**
    - Terminati i giri $N - 1$ Bellman Ford verifica ancora una cosa:
    - se trova una strada che abbassa il costo verifica che non si tratti di un ciclo.