# 8. Complessita algoritmi non ricorsivi

## Teoria

$T(n)$ rispetto alle istruzioni del codice:
- assegnazioni -> sono operazioni elementari $O(1)$
- sequenze -> istruzioni una dopo l'altra, verifichi solo quella che impiega piu tempo e utilizzi il suo $T(n)$
- selezione IF-ELSE -> verifichi il tempo di entrambi i blocchi e prendi quello maggiore
- cicli (for while) -> $i \times T_{istruzioni} $
    - ad esempio se in un for le istruzioni sono $O(1)$ e $i = n$ allora complessita di ciclo = $O(n)$

## Esempi pratici

1. Fattoriale iterativo -> $5! = 5 \times 4 \times 3 \times 2 \times 1$ sarebbe un ciclo da 5n quindi, ma noi non consideriamo le costanti quindi complessita = $O(n)$ lineare
2. Fibonacci iterativo -> anche qui ce un for, fa semplici calcoli e quindi di nuovo $O(n)$ lineare
3. Ricerca del massimo -> scorriamo l array alla ricerca del massimo, se array lungo n allora semplice $O(n)$ lineare

## Conclusione

In generale per gli algoritmi non ricorsivi la complessità è data quasi sempre dai cicli:
1. nessun ciclo ? $O(1)$
2. ciclo che scorre fino ad n ? $O(n)$
3. cicli annidati ? $O(n^2)$ 