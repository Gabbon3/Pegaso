# 40. Programmazione dinamica

Utilizzo di strategie diverse quando un problema presenta dei sotto-sotto problemi.

La programmazione dinamica risolve ogni sotto-problema una sola volta e salva la sua soluzione in una __tabella__.
Permette di evitare ripetizioni.

Si applica a __problemi di ottimizzazione__ (problemi con tante soluzioni ma solo una __ottima__)

### Processo di sviluppo di un algoritmo

1. caratterizzare la struttura di una soluzione ottima
2. si definisce in modo ricorsvo il valore di una soluzione ottima
3. si calcola il valore di una soluzione ottima secondo uno schema __bottom-up__
4. si costruisce la soluzione ottima dalle informazioni calcolate.

le prime 3 fasi formano la base per risolvere un problema applicando la programmazione dinamica
la __quarta puo essere omessa__ se si cerca soltanto il valore di una soluzione ottima

a volte nella 4 fase si possono aggiungere info aggiuntive per + ottimizzazione

### Memoization

Tecnica per definire la __cache__, calcoli il valore 1 volta e lo memorizzi in una tabella, la cache a tutti gli effetti

## Problema del domino

si hanno delle tessere del domino di dimensione 2 * 1, si vuole scrivere un algoritmo efficiente, che prende in input `n` e restituisca il numero di possibili __disposizioni__ di `n` tessere in un rettangolo $2 \times n$

- __`n` = 0 --> 1 disposizione (disposizione nulla)__
- `n` = 1 --> 1 la tessera in verticale
- `n` = 2 --> 2 posizioni, due tessere in verticale o in orizzontale
- `n` = 4 --> 5 disposizioni

Creare una formula ricorsiva $DP[n]$ (Dinamic Progr.)

- se tassello verticale: $DP[n - 1]$ 
- se tassello orizzontale: $DP[n - 2]$ perche se 1 è orizzontale necessita perforza di un altro sopra di esso

riassumento potremmo dire che: $$DP[n] = DP[n - 1] + DP[n - 2]$$

Alla fine otteniamo la __serie di fibonacci__

### Domino V1

Algoritmo:
- Classico di fibonacci

Complessita:
- $\Theta(2^n)$

### Domino V2

Algoritmo
```c
int domino_v2(int n) {
    DP = new int[0..n]
    DP[0] = DP[1] = 1
    for (int i = 2; i <= n; i++) {
        DP[i] = DP[i - 1] + DP[i - 2]
    }
    return DP[n];
}
```
La tabella di memoization viene usata per calcolare man mano i risultati

Complessita sempre in termini di spazio, è n perche l array che usiamo va da __0 a n__:
- $\Theta(n)$

### Domino V3

Algoritmo:
```c
int dominio_v3(int n) {
    int DP0 = 1
    int DP1 = 1
    int DP2 = 1
    for (int i = 2; i <= n; i++) {
        DP0 = DP1
        DP1 = DP2
        DP2 = DP0 + DP1
    }
}
```

Complessita in termini di occupazione di spazio:
- $\Theta(1)$ questo perche usiamo solo 3 variabili

### Tabella finale delle complessita

| Funzione | Complessità temporale <br> n piccolo | Complessità temporale <br> n grande | Complessità spaziale <br> n piccolo | Complessità spaziale <br> n grande |
| --- | --- | --- | --- | --- |
| domino v1 | $O(2^n)$ | $O(2^n)$ | $O(n)$ | $O(n^2)$ |
| domino v2 | $O(n)$ | $O(n^2)$ | $O(n)$ | $O(n^2)$ |
| domino v3 | $O(n)$ | $O(n^2)$ | $O(1)$ | $O(n)$ |


## Fibonacci e sezione aurea

esiste un legame tra la serie di fibonacci e la sezione aurea.

Sezione aurea -> $\phi$ -> `1,6180339887`

Questo numero si ottiene, sempre in maniera piu precisa, dividendo due numeri vicini nella sequenza di fibonacci.

Quindi in breve la sezione aurea $a / b$ è definita come il rapporto tra il numero maggiore e il minore e deve soddisfare la seguente relazione:

$$a / b = (a + b) / a$$

Puo anche essere scritta come:

$$a^2 = ab + b^2$$

Oppure come:

$$b / a = (\sqrt 5 - 1) / 2$$

Questa ultima equazione infatti fornisce il valore esatto del rapporto della sezione aurea