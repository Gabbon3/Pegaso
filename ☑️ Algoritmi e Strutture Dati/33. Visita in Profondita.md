# Visita in Profondita

## 1. Impolementazione

Letteralmente definisce il DFS (Depth First Search).

La struttura dati del DFS è lo Stack, quindi una coda LIFO, la famosa __Pila__.
Questa pila puo essere:
- __esplicita__ (se implementiamo manualmente un array/lista)
- __implicita__ (se utilizziamo la __ricorsione__)

__Obiettivo__: la DFS viene usata per esplorare l intero grafo e se:
- __grafo connesso__ -> genera un singolo _Albero DF_ (Depth First Tree)
- __grafo non connesso__ -> la visita riparte per ogni componente connessa non ancora visitata, generando una __Foresta DF__ (una collezione di alberi).

__Complessità__: la complessità temporale è $O(n + m)$ (n nodi m archi), identica alla BFS, perche nel caso peggiore _visitiamo_ ogni nodo e attraversiamo ogni arco una volta.

## 2. Implementazione

1. __DFS Ricorsiva__: piu elegante. Si visita un nodo `u`, si marca come visitato e si chiama ricorsivamente la funzione su tutti gli archi vicini `v` non ancora visitati
    - _Rischio_: su grafi molto grandi lo stack potrebbe stare stretto e generare __Stack Overflow__ superando la memoria dedicata allo stack del sistema operativo (che varia da 1MB windows a 8MB su Linux Mac)
2. __DFS iterativa__: simula la ricorsione utilizzando uno `Stack` esplicito.
    - _Nota tecnica_: un nodo viene inserito nello stack quando viene scoperto, ma viene marcato come "visitato" definitivamente solo quando viene __estratto__ (pop) dallo stack. Ricordiamoci la struttura LIFO

## 3. I "Timestamp": Tempo di Scoperta e di Fine

Per analizzare le proprietà del grafo non basta un booleano `visited`. Usiamo un contatore globale `counter` e due array per ogni nodo `u`:
- $d[u]$ Discovery time -> il momento (valore del contatore) in cui il nodo `u` viene visitato per la prima volta (diventa __grigio__)
- $f[u]$ Finish time -> il momento in cui abbiamo terminato di visitare tutti i vicini di `u` e facciamo backtracking (il nodo diventa __nero__).

Esempio: se iniziamo da A, allora $d[A] = 1$. Se ci spostiamo su B allora $d[B] = 2$, se B non ha vicini allora la visita a B è terminata quindi $f[B] = 3$ tornando poi indietro ad $A$.
Alla fine otteremo un intervallo $[d[u], f[u]]$ che rappresenta il tempo in cui il nodo `u` è rimasto "attivo" nello stack.

## 4. Classificazione degli archi

esiste una classificazione degli archi in base allo stato del nodo di destinazione.

supponiamo di analizzare l'arco $(u, v)$:
1. __Archi dell'albero (Tree Edges)__ -> sono gli archi che portano a un nodo `v` __non ancora visitato__
2. __Archi all'indietro (Back Edges)__ -> archi che collegano `u` al suo __antenato__ nell'albero DF.
    - _come riconoscerli_: il nodo `v` è gia stato scoperto $d[v] \neq 0$ ma non è ancora concluso $f[v] == 0$. è ancora nello STACK
    - _significato_: la presenza di un arco all'indietro indica matematicamente che il grafo contiene un __ciclo__
3. __Archi in avanti (Forward Edges)__ -> collegano `u` ad un __discendente__ nell'albero ce pero non è un suo figlio diretto (è stato gia visitato da un altro percorso)
4. __Archi di attraversamento (Cross Edges)__ -> collegano due nodi che non sono parenti (ne antenati ne discendenti). Possono collegare due rami diversi dallo stesso albero o due alberi diversi della stessa foresta.
    - _condizione_: $d[u] > d[v]$ e il nodo $v$ è già concluso ($f[v] \neq 0$).