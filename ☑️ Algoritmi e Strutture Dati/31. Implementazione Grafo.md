# 31. Implementazione Grafo

## 1. Matrice di Adiacenze: La Griglia

- __funzionamento__: se A è connesso a B, mettiamo 1 a `griglia[A][B]` se non sono collegati 0
- __grafi non orientati__: se A connesso a B allora anche B connesso ad A, quindi valorizzare: `griglia[A][B]` e `griglia[B][A]`, la griglia è __simmetrica__
    - la matrice risultante sara una __matrice triangolare superiore__
- __grafi pesati__: invece di 0 e 1, mettiamo il peso. se non ce collegamento allora $\infty$

### Pregi Difetti

- __velocita__ -> $O(1)$ per rispondere alla domanda "A e B sono collegati?", basta fare `griglia[A][B]`.
- __spreco spazio__ -> occupa sempre $O(n^2)$ spazio. Se hai 1000 nodi ma solo 10 achi la tabella avrà milioni di celle, quasi sempre 0. Ideale per grafi __densi__ (quindi ricchi di archi)

## 2. Lista di Adiacenza: "La Rubrica"

Ogni nodo ha un elenco contatti personale:
- __funzionamento__ -> usiamo un array dove ogni cella rappresenta un nodo. In ogni cella ce una lista che contiene solo i nodi a cui quel nodo è effettivamente connesso.
- __esempio__ -> A connesso a B e D allora `[B, D]`

### Pregi Difetti

- __Risparmio Spazio__ -> Occupa $O(n + m)$ (nodi + archi). Ottimo per grafi sparsi
- __Lentezza relativa__ -> per sapere se due nodi n sono connessi dobbiamo scorrere tutta la lista di A finche non troviamo B $O(n)$

## 3. Implementazione in Python

```python
class GraphNotOriented:
    def __init__(self, vertices):
        self.V = vertices
        self.graph = defaultdict(list)

    def add_edge(self, u, v):
        # Aggiungo v alla lista di u E u alla lista di v (perché è reciproco)
        self.graph[u].append(v)
        self.graph[v].append(u)

    # Qui implementiamo il metodo per il 
    # GRAFO ORIENTATO PESATO:
    def add_edge(self, u, v, weight):
    # Solo in una direzione: da u verso v con un certo peso
    self.graph[u].append((v, weight)) [cite: 597]
```

## 4. Algoritmo: ce un ciclo?

Come capire se in un grafo non orientato ce un ciclo ("è possibile girare in tondo?")
__La logica__: usiamo la ricorsione e un array di punti visitati `visited`

1. parto da un nodo n e lo segno visitato
2. guardo i suoi vicini
3. se trovo un nodo __gia visitato__ e che __non è il nodo da cui sono appena arrivato__ (il padre) allora ho beccato un ciclo
4. se non ce continuo ad esplorare fino a che non ho visitato tutto.

