# 45. Las Vegas

## 1. Introduzione

L'algoritmo di Las Vegas **restituisce sempre la risposta corretta**.

è dunque utile in situazioni in cui è accettabile avere un tempo di esecuzione variabile, purche come dicevamo, venga restituito il risultato corretto.

La vera scommessa la si fa sul **tempo** infatti il tempo di esecuzione è _variabile_

- potrebbe impiegare 1 ms
- oppure 10 minuti
- ce la possibilità che non possa mai terminare

### Confronto con i deterministici

- **Deterministici**: seguono passi rigidi e ti danno una soluzione esatta in un tempo prevedibile.
    - sono da usare quando si ricerca la certezza totale
- **Las Vegas**: usa la probabilità (scelte casuali) per cercare di arrivare alla soluzione piu in fretta rispetto ad un approccio deterministico, mantenendo la stessa correttezza.

### Esempi

- **ricerca di un elemento in una tabella hash**: cerco un elemento utilizzando diverse funzioni di hash casuali
- **algoritmo di ricerca di un elemento in un BST bilanciato**: si muove nell albero in maniera casuale cercando un elemento
- **clustering k-means probabilistico**: variante del k-means utilizzato nel cluster dei dati. In questo caso, i centroidi dei cluster vengono scelti casualmente. In casi particolari questo metodo è migliore di quello deterministico
- **selezione del mediano**: trova il mediano in un insieme di numeri utilizzando una strategia casuale per scegliere il pivot. Il tempo di esecuzione dipende dalla distribuzione dei valori nell insieme di numeri e dalla strateia scelta.
- **Dijkstra**: su un grafo pesato scegliamo i nodi da visitare in maniera casuale. con la fortuna becchiamo la strada piu breve in meno tempo
- **Quicksort**: il pivot viene scelto casualmente (anziche l'ultimo, il primo o l'elemento centrale del subarray)
- **Rabin-Karp**: per la ricerca di sottostringhe, usa una _funzione di hash_ per confrontare le sottostringhe con la stringa di ricerca, la scelta della funzione di hash e del valore iniziale sono casuali.

### Quando usarlo

- applicazioni che richiedono grandi risorse computazionali
- problemi che richiedono elaborazioni di dati enormi
- problemi in cui la precisione non è essenziale e dove l'errore puo essere tollerato come nell analisi statistica

### Combinazione

Las Vegas potrebbe essere usato insieme ad altri algoritmi per essere piu efficiente, ad esempio con _Montecarlo_ per risolvere problemi di **ricerca** o di **conteggio approssimato**

### Crittografia

La relazione con la crittografia è stretta, ad esempio in **RSA** è di fatto molto lento e complesso, grazie a Las Vegas si puo accellerare l'elaborazione.

## 2. Quicksort

Quicksort deterministico, scegliamo il pivot manualmente prendendo sempre il primo elemento di ogni array:

```py
def quicksort(arr):
    if len(arr) <= 1:
        return arr
    else:
        pivot = arr[0]
        left = []
        right = []
        for i in range(1, len(arr)):
            if arr[i] < pivot:
                left.append(arr[i])
            else:
                right.append(arr[i])
        return quicksort(left) + [pivot] + quicksort(right)
```

Questo a seguire invece sceglie il pivot casualmente

```py
import random

def quicksort_las_vegas(arr):
    if len(arr) <= 1:
        return arr
    else:
        pivot = random.choice(arr)
        left = [x for x in arr if x < pivot]
        middle = [x for x in arr if x == pivot]
        right = [x for x in arr if x > pivot]
        return quicksort_las_vegas(left) + middle + quicksort_las_vegas(right)
```

## 3. Selezione del Mediano

Array lungo 1.000.000 di numeri disordinati e vogliamo trovare esattamente il numero che sta a metà (_la mediana_) oppure il 7° numero piu piccolo
- **metodo bruto** (quicksort completo): ordiniamo l'array $O(n log n)$ e poi prendiamo l'elemento alla posizione centrale `arr[500.000]`.
    - abbiamo sprecato risorse per ordinare 1 milione di numeri per prenderne 1
- **las vegas** (quickselect):
    - supponiamo di cercare il 5° elemento piu piccolo:
    1. scegliamo un pivot a caso
    2. dividiamo l'array in: `{minori}` - `{pivot}` - `{maggiori}`
    3. verifichiamo il pivot è a posizione 8? se noi cerchiamo il 5° allora sarà sicuramente a sinistra
    4. richiamo quickselect solo sulla parte sinistra e cosi via finche non trovo il numero.

### Complessità

- Quicksort $O(n log n)$
- **Quickselect $O(n)$ perche**: ogni volta dividiamo l'array in 2 e scartiamo una parte

### Algoritmo di selezione del mediano

```py
import random

def select_median(arr):
    if len(arr) == 1:
        return arr[0]
    else:
        pivot = random.choice(arr)
        left = [x for x in arr if x < pivot]
        right = [x for x in arr if x > pivot]
        k = len(left)
        if len(left) == 0:
            return pivot
        elif k == len(arr):
            return arr[k-1]
        else:
            return select_median(left) if k <= len(arr)/2 else select_median(right)
```