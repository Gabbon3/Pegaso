# 20. Liste

## 1. Intruduzione e Tassonomie

1. identikit della lista:
    - cos'è -> una collezione ordinata di elementi accessibili tramite indice
    - caratteristiche chiave:
        - dinamica -> la sua dimensione cambia durante l esecuzione
        - sparsa -> gli elementi non sono vicini in memoria
        - ordinata -> gli elementi seguono l ordine logico (spesso basato su chiavi)
2. operazioni: le operazioni base di una lista simili a quelle elencate nel documento precedente dove abbiamo search, insert, delete, minimum, maximum, successor, predecessor: naviga l ordine logico

## 2. La lista (Definizione e Algoritmi)

1. __definizione formale__ matematica -> una lista è definita come una tripla $L = (E, t, S)$ dove:
    - $E$ : insieme degli elementi
    - $t$ : la testa (primo elemento)
    - $S$ : relazione successiva
    - regola d'oro: ogni elemento ha un successore tranne l ultimo che punta a null
2. __perche non usare un vettore classico__ ? inserire dinamicamente un elemento con un vettore semplice non sarebbe possibile o costoso (ricopiare l intero array)
3. I __4 problemi fondamentali__:
    1. Visita -> attraversare tutti gli elementi una sola volta
    2. Ricerca -> trovare se un valore esiste
    3. Inserimento -> aggiungere un nuovo valore
    4. Rimozione -> eliminare un valore
4. __algoritmi di manipolazione__:
    - _eliminazione in testa (head)_:
        1. identificare la radice $t$
        2. aggiorni il puntatore della radice
        3. liberi la memoria con `delete`
    - _inserimento in testa_:
        1. allochi memoria `new`
        2. imposti next all $t$ attuale
        3. aggiorni la radice per puntare al nuovo primo nodo
    - _inserimento eliminazione generica_:
        - scorri fino al punto desiderato e cambi i puntatori del nodo precedente successivo...
        - NOTA: queste operazioni hanno complessita $O(n)$

## 3. Gestione della memoria dinamica

1. `malloc` vs `new`:
    - `malloc()` vs `free()` __C__ : gestione manuale grezza della memoria
    - `new` vs `delete` __C++__ : operatori intelligenti introdotti solo dopo in c++
2. __memory leak__ : se usi `new` e non usi `delete` dopo ti ritrovi la memoria piena di dati inutilizzati quindi incorri nella _perdita di memoria_
3. l'__heap__ la memoria dinamica è gestita nell heap, una zona della speciale della RAM. 