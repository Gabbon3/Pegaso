# Paniere Ingegneria del Software
## Introduzione all'ingegneria del software

### Difficoltà 2

> Il termine ingegneria del software:
- **è stato coniato nel 1968 come risposta allo stato desolante dell'arte dello sviluppo di software di qualità nei tempi e nei costi previsti** ✅
- è stato coniato nel 1958 come risposta allo stato desolante dell'arte dello sviluppo di software di qualità nei tempi e nei costi previsti
- è stato coniato nell'ultimo decennio come risposta alla complessità dello sviluppo di software di qualità nei tempi e nei costi previsti
- è stato previsto come risposta alla crescente complessità di sviluppo di software di qualità e distribuito

> Nei processi complessi come nella ingegneria del software:
- **non esiste una soluzione unica e uno strumento perfettamente utile** ✅
- la soluzione va ottenuta sfruttando metodi ben conosciuti
- esiste una soluzione ottima ma è difficile e costosa da ottenere
- va utilizzato un metodo univoco e valido in maniera generale

> La programmazione orientata agli oggetti:
- nasce dalla applicazione della metodologia UML
- è da adottarsi in tutti gli ambiti dove viene considerata ingegneria del software
- **consente l'incapsulamento dei dati, l'ereditarietà e il polimorfismo, rendendo i sistemi software complessi più modulari e riutilizzabili** ✅
- è l'unico paradigma necessario nella metodologia UML

> Un software professionale è:
- **destinato ad essere utilizzato da persone diverse dai loro sviluppatori** ✅
- destinato ad essere utilizzato in industria
- dedicato ad un singolo individuo che abbia un opportuno grado di professionalità
- dedicato ad un gruppo di professionisti

> Le attività fondamentali dell'ingegneria del software sono:
- **la specifica, lo sviluppo, la convalida e l'evoluzione del software** ✅
- la specifica, lo sviluppo, la vendita e l'evoluzione del software
- la qualifica, l'ottimizzazione, la convalida e la specializzazione del software
- la gestione, il debug, la convalida e la concezione del software

### Difficoltà 3

> L'ingegnere si trova spesso di fronte a:
- problemi ben definiti e deve affidarsi a metodi matematici per valutare le soluzioni
- problemi di natura tecnica, e deve affidarsi a metodi classici per valutare le soluzioni
- soluzioni complicate, ma può contare su metodologie e strumenti consolidati ed universali
- **problemi non ben definiti e a soluzioni parziali, e deve affidarsi a metodi empirici per valutare le soluzioni** ✅

> L'ingegneria del software è:
- è una branca della ingegneria dei sistemi di elaborazione che si occupa di tutti gli aspetti della produzione, dalla nascita al funzionamento e alla manutenzione
- **è una disciplina ingegneristica che si occupa di tutti gli aspetti della produzione del software, dalla nascita al funzionamento e alla manutenzione** ✅
- è una disciplina ingegneristica che si occupa di tutti gli aspetti della ideazione del software, fino alla sua nascita
- è una disciplina ingegneristica che si occupa di perfezionare i meccanismi con cui avvengono le elaborazioni dovute al software e della loro manutenzione

> Un sistema software sviluppato professionalmente:
- **può essere formato da vari programmi indipendenti e da file di configurazione che sono utilizzati per impostare tali programmi** ✅
- non può essere formato da programmi indipendenti ma richiede diversi file di configurazione che sono utilizzati per impostarlo
- non è necessaria la produzione di documentazione e tutorial Web associati
- richiede una competenza molto avanzata agli sviluppatori sui linguaggi di programmazione

### Difficoltà 4

> Nell'ambito della ignegneria del software non è tipico che:
- il 60% dei costi è legato allo sviluppo, il 40% alle prove
- per il software personalizzato, i costi di evoluzione spesso superano quelli di sviluppo
- si consideri una parte degli aspetti dello sviluppo di sistemi informatici, inclusi quelli hardware, software e di processo
- **si cerchi di evitare la varietà di richieste del committente e le eventuali aggiuntive esigenze su attributi di qualità non funzionali** ✅

> Non è un attributo non funzionale:
- la manutenibilità
- l'efficienza
- il consumo di memoria
- **l'interfaccia utente** ✅

---
## Introduzione ai processi software

### Difficoltà 1

> Una caratteristica chiave dei prodotti software rispetto ai software ad hoc:
- sono sempre sviluppati su misura per il cliente
- i costi di sviluppo sono a carico di un singolo cliente
- **non dipendono dalle specifiche di un cliente individuale** ✅
- richiedono meno aggiornamenti rispetto ai software ad hoc

### Difficoltà 2

> Il principale vantaggio dello sviluppo agile di prodotti software:
- riduzione dei costi di manutenzione del software
- supporto continuo al prodotto da parte dello sviluppatore
- **facilitazione nel raggiungimento tempestivo delle esigenze del mercato** ✅
- eliminazione completa della necessità di test

> La definizione di linea di prodotto software:
- una piattaforma per lo sviluppo di applicazioni web
- **un insieme di software con un nucleo comune, adattabile ai bisogni specifici del cliente** ✅
- un sistema software creato esclusivamente per un singolo cliente
- un software autonomo senza dipendenze esterne

> Lo scopo principale del test del sistema nel processo di convalida:
- **convalida della conformità ai requisiti e verifica delle interfacce** ✅
- semplificazione del debug degli errori
- riduzione del costo complessivo del progetto
- generazione della documentazione tecnica

> L'attività che non rientra tra le fasi principali dell'ingegneria dei requisiti:
- deduzione e analisi dei requisiti
- convalida dei requisiti
- **progettazione architettonica** ✅
- specifica dei requisiti

> La definizione di refactoring nel contesto dello sviluppo software:
- miglioramento dell'efficienza del codice senza modificarne la struttura
- **miglioramento della struttura e dell'organizzazione del codice senza alterarne il comportamento** ✅
- ottimizzazione del database per il sistema
- sviluppo di nuove funzionalità per il software

### Difficoltà 3

> Le attività fondamentali dell'ingegneria del software:
- analisi dei dati, sviluppo, test e marketing
- **specifica, sviluppo, convalida ed evoluzione** ✅
- progettazione, vendita, implementazione e revisione
- pianificazione, scrittura, debug e manutenzione

> Una differenza chiave tra i metodi agili e i metodi tradizionali di sviluppo:
- i metodi agili richiedono più documentazione rispetto ai metodi tradizionali
- i metodi tradizionali sono più rapidi nel rispondere ai cambiamenti
- **i metodi agili enfatizzano lo sviluppo iterativo e la rapida consegna** ✅
- i metodi tradizionali si concentrano unicamente sulla programmazione

> Il vantaggio principale della prototipazione nel processo di sviluppo software:
- eliminazione della necessità di test formali
- **validazione e perfezionamento dei requisiti prima della produzione** ✅
- riduzione dei costi di distribuzione del software
- incremento della durata complessiva del progetto

### Difficoltà 4

> Lo svantaggio principale della consegna incrementale:
- difficoltà nell'integrazione di nuove funzionalità nei sistemi già sviluppati
- necessità di una specifica completa all'inizio del progetto
- **funzionamento limitato nella sostituzione di sistemi esistenti** ✅
- Incremento significativo dei costi di sviluppo

---
## Sviluppo Agile

### Difficoltà 2

> Qual è il principio fondamentale dei metodi agili:
- modello a cascata
- documentazione approfondita
- specifica completa dei requisiti
- **consegna incrementale** ✅

> Come sono espressi i requisiti nella programmazione estrema:
- documentazione di progetto
- **storie utente** ✅
- diagrammi UML
- specifiche tecniche

> Qual è uno degli obiettivi principali dei metodi agili:
- **coinvolgimento continuo del cliente** ✅
- esclusione delle modifiche durante il progetto
- documentazione dettagliata
- riduzione del coinvolgimento del cliente

> Cosa si intende per 'refactoring':
- specifica completa dei requisiti
- scrittura dei test prima del codice
- **revisione e miglioramento continuo del codice** ✅
- integrazione immediata del sistema

> Cosa rappresenta il 'product backlog' in Scrum?
- **una lista di elementi da completare** ✅
- una lista di bug da risolvere
- una roadmap dettagliata
- un documento di specifica tecnica

### Difficoltà 3

> Qual è la durata tipica di uno sprint in Scrum:
- più di 6 mesi
- **da 2 a 4 settimane** ✅
- meno di una settimana
- da 1 a 2 mesi

> Quale pratica è centrale nella programmazione estrema:
- pianificazione up-front
- documentazione estesa
- **refactoring continuo** ✅
- specifica dettagliata dei requisiti

> Quale pratica prevede due sviluppatori che lavorano insieme:
- integrazione continua
- refactoring continuo
- sviluppo basato su test iniziali
- **programmazione a coppie** ✅

> Quale termine descrive un rilascio frequente e incrementale di software:
- documentazione incrementale
- test su larga scala
- grandi progetti
- **piccole release** ✅

### Difficoltà 4

> Quale framework è usato per scalare i metodi agili in grandi progetti:
- ASM (Agile Scaling Model)
- **SAFe (Scaled Agile Framework)** ✅
- Scrum base
- XP (Extreme Programming)

---
## Introduzione al ciclo di vita del software

### Difficoltà 2

> Quale modello è adatto a requisiti stabili:
- DevOps
- Agile
- modello a spirale
- **Waterfall** ✅

> Qual è un obiettivo del modello spirale:
- garantire la rigidità
- **gestire il rischio iterativamente** ✅
- limitare le revisioni
- eliminare le iterazioni

### Difficoltà 3

> Qual è un esempio di caso studio nel ciclo di vita del software:
- un'applicazione senza testing
- un progetto senza pianificazione
- un software che non supporta aggiornamenti
- **un sistema gestionale implementato iterativamente** ✅

> Qual è una sfida principale nel ciclo di vita del software:
- sistema senza feedback
- requisiti sempre stabili
- **requisiti in evoluzione** ✅
- debug automatico

> Cosa significa CI/CD:
- automazione completa
- creazione iterativa di codice
- modello collaborativo
- **integrazione e distribuzione continua** ✅

> Quale vantaggio offre l'intelligenza artificiale nello sviluppo software:
- eliminazione totale del testing
- riduzione della qualità
- sostituzione dei team
- **automazione del testing** ✅

> Quale tecnica migliora la qualità del software:
- concentrarsi solo sugli stakeholder
- minimizzare il testing
- **test unitari automatizzati** ✅
- ignorare i requisiti non funzionali

### Difficoltà 4

> Cosa descrive il ciclo di vita del software:
- un modello per specifiche non stabili
- un sistema di debug automatico
- **una sequenza strutturata di fasi** ✅
- un processo unicamente iterativo

> Come DevOps riduce i rischi:
- **rilevamento e risoluzione precoce dei problemi** ✅
- sostituzione di test manuali
- eliminazione della collaborazione tra team
- rimozione di feedback iterativi

### Difficoltà 5

> Qual è uno dei vantaggi del DevOps:
- minore collaborazione
- distribuzioni manuali
- **riduzione del time-to-market** ✅
- rigidità nel ciclo di sviluppo

---
## Sviluppo dei processi del ciclo di vita

### Difficoltà 2

> Qual è l'obiettivo principale dell'ingegneria dei requisiti:
- **garantire che il sistema soddisfi le esigenze degli utenti** ✅
- ridurre i costi di sviluppo
- eliminare completamente i rischi
- accelerare la documentazione

> Quale vantaggio principale offre un'architettura a strati:
- aumenta la complessità del sistema
- riduce i tempi di sviluppo
- rende superflua la documentazione
- **facilita il test indipendente dei componenti** ✅

> Qual è un aspetto critico dell'ingegneria dei requisiti:
- **collegare le aspettative degli stakeholder alla funzionalità del sistema** ✅
- ridurre il tempo di sviluppo saltando i test
- ignorare i cambiamenti dei requisiti durante il progetto
- semplificare il ciclo di feedback

### Difficoltà 3

> Cosa caratterizza un modello ibrido nello sviluppo software:
- **combina agilità e rigore** ✅
- elimina i test funzionali
- si basa solo sulla documentazione iniziale
- evita l'uso di feedback iterativi

> Perché i cicli di feedback sono fondamentali:
- semplificano la gestione delle risorse
- evitano la necessità di progettazione
- **migliorano complessivamente la qualità del software** ✅
- riducono il bisogno di test

> Cosa significa personalizzare un modello SDLC:
- **adattarlo alle esigenze specifiche del progetto** ✅
- rimuovere le fasi di pianificazione
- ridurre i requisiti del cliente
- aumentare le risorse tecniche

> Qual è lo scopo principale dei cicli di feedback:
- ridurre il tempo di sviluppo a ogni costo
- **migliorare la qualità del software** ✅
- evitare l'interazione con gli stakeholder
- rimuovere la necessità di test manuali

> Quando è utile utilizzare un modello Agile puro:
- per eliminare i test nelle fasi finali
- **in contesti dinamici con requisiti in evoluzione** ✅
- quando è necessaria una forte documentazione iniziale
- per progetti con requisiti ben definiti

> Cosa si intende per prototipazione nell'ingegneria dei requisiti:
- creare una documentazione finale immediata
- sostituzione di test manuali
- eliminare la fase di validazione dei requisiti
- **creare modelli iniziali per raccogliere feedback dagli stakeholder** ✅

### Difficoltà 4

> Qual è uno dei principali vantaggi della progettazione dettagliata:
- **definire con precisione le interazioni tra i moduli** ✅
- eliminare la necessità di test funzionali
- ridurre il numero di documenti richiesti
- rimuovere completamente i rischi

---
## Modelli di ciclo di vita del software

### Difficoltà 2

> Qual è l'obiettivo principale dei modelli di ciclo di vita dello sviluppo software:
- eliminare la necessità di test
- ridurre i costi di sviluppo senza altre considerazioni
- automatizzare completamente lo sviluppo software
- **guidare lo sviluppo e la manutenzione del software** ✅

> Qual è la caratteristica principale del modello Waterfall:
- **suddivisione sequenziale delle fasi** ✅
- iterazioni rapide con feedback costante
- collaborazione continua tra stakeholder
- gestione completa del rischio

> Qual è il principale vantaggio del modello a spirale:
- eliminazione dei prototipi
- automazione dello sviluppo
- sequenzialità delle fasi
- **gestione del rischio in ogni iterazione** ✅

> Qual è un aspetto distintivo dei modelli iterativi:
- **possibilità di perfezionamento progressivo** ✅
- sequenzialità rigorosa
- assenza di feedback utente
- esclusione di fasi di test

### Difficoltà 3

> In cosa consiste il modello iterativo:
- **sviluppo incrementale con feedback continuo** ✅
- implementazione immediata del codice
- pianificazione completa iniziale
- eliminazione del testing

> Quando è ideale utilizzare il modello predittivo:
- **per progetti con requisiti ben definiti e stabili** ✅
- per prototipi rapidi
- per progetti con requisiti in continua evoluzione
- per progetti a lungo termine e complessi

> Qual è una limitazione del modello Waterfall:
- non supporta la documentazione
- **non gestisce bene i cambiamenti nei requisiti** ✅
- richiede una pianificazione flessibile
- non consente testing approfonditi

> Quando utilizzare il modello iterativo:
- per progetti con requisiti statici
- per progetti con tempi ridotti ma esigenze fisse
- per eliminare completamente il testing
- **per progetti complessi che richiedono feedback costante** ✅

### Difficoltà 4

> Qual è un esempio di applicazione del modello a spirale:
- creazione di un'app mobile con funzionalità fisse
- automazione di test
- progettazione di un sito web semplice
- **sviluppo di sistemi di difesa militare complessi** ✅

> Qual è una caratteristica del modello a spirale
- **utilizzo di prototipi per ridurre i rischi** ✅
- consegne incrementali rapide
- fasi rigide e non modificabili
- sviluppo senza coinvolgimento degli stakeholder

---
## Introduzione alla modellazione

### Difficoltà 1

> Quale delle seguenti affermazioni è vera riguardo ai modelli concettuali:
- sono creati solo dopo l'implementazione del software
- contengono dettagli specifici su tabelle e attributi
- sono direttamente implementati in database relazionali
- **aiutano gli stakeholder a comprendere la struttura generale di un sistema** ✅

### Difficoltà 2

> Qual è lo scopo principale della modellazione nel software engineering:
- **semplificare, analizzare e comunicare sistemi complessi** ✅
- scrivere direttamente il codice
- evitare la documentazione
- rendere il software più efficiente

> Cosa distingue un modello concettuale da un modello logico:
- il modello logico viene prima del concettuale
- **il modello concettuale è più astratto e non include dettagli tecnici** ✅
- il modello concettuale è solo per sistemi hardware
- il modello logico è sempre implementato direttamente nel codice

> Quale tra i seguenti è un vantaggio chiave della modellazione:
- sostituisce la necessità di scrivere codice
- rende il software più complesso
- **migliora la comunicazione tra stakeholder** ✅
- evita la necessità di testare il software

### Difficoltà 3

> Che cos'è UML:
- un framework per il test del software
- un metodo per scrivere codice senza errori
- un linguaggio di programmazione
- **un linguaggio standardizzato per la modellazione software** ✅

> Qual è il principale vantaggio di UML:
- **facilita la comunicazione tra i vari stakeholder** ✅
- sostituisce completamente il codice
- non è adatto ai progetti software complessi
- viene utilizzato solo per la documentazione, non per la progettazione

> Qual è uno dei principali miglioramenti di UML 2.5 rispetto a UML 2.0:
- aumentato numero di simboli grafici
- eliminazione del supporto ai diagrammi classici
- aggiunta di più diagrammi
- **maggiore semplificazione e leggibilità** ✅

### Difficoltà 4

> Qual è la funzione principale dei diagrammi UML:
- **rappresentare diversi aspetti del sistema** ✅
- scrivere direttamente il codice
- creare pagine web
- analizzare le prestazioni di un computer

> Perché UML 2.5 ha rimosso alcuni elementi ridondanti:
- per eliminare la modellazione
- per rendere rigoroso un sottoinsieme di UML
- per ridurre il numero di diagrammi disponibili
- **per rendere il linguaggio più semplice e intuitivo** ✅

### Difficoltà 5

> Quale tra questi NON è un diagramma UML ufficiale:
- diagramma delle classi
- diagramma di sequenza
- **Diagramma di struttura dati** ✅
- diagramma di macchina a stati

---
## Diagrammi delle classi e degli oggetti

### Difficoltà 1

> Che cosa rappresenta un'annotazione in UML:
- **una nota testuale collegata a un elemento** ✅
- un oggetto astratto
- un elemento visivo di collegamento
- una relazione tra classi

### Difficoltà 2

> Qual è lo scopo principale di un diagramma delle classi in UML:
- rappresentare la configurazione hardware
- **definire la struttura statica di un sistema** ✅
- definire le transazioni tra oggetti
- mostrare il flusso di controllo di un sistema

> Qual è il simbolo utilizzato per indicare una composizione in UML:
- **un rombo pieno** ✅
- una freccia semplice
- un rombo vuoto
- un cerchio collegato alla classe

### Difficoltà 3

> Come vengono rappresentate le operazioni in un diagramma UML:
- con un cerchio collegato alla classe
- con un rettangolo con una freccia
- **con una riga di testo nella sezione delle operazioni della classe** ✅
- con un'icona accanto alla classe

> Cosa rappresenta una generalizzazione in UML:
- una rappresentazione di un'operazione
- **una relazione tra una superclasse e una sottoclasse** ✅
- una connessione tra componenti hardware
- un collegamento tra oggetti

> Qual è lo scopo di un diagramma degli oggetti in UML:
- mostrare le transazioni tra oggetti
- definire il ciclo di vita di un oggetto
- definire le classi di un sistema
- **mostrare lo stato di un sistema in un momento specifico** ✅

### Difficoltà 4

> In UML, cosa indica la molteplicità 0..*:
- esattamente una istanza
- almeno due istanze
- **zero o più istanze** ✅
- un numero definito di istanze

> Qual è la differenza tra operazione e metodo in UML:
- non c'è differenza tra i due
- sono la stessa cosa
- un metodo definisce cosa fare, un'operazione definisce come farlo
- **un'operazione definisce cosa fare, un metodo definisce come farlo** ✅

### Difficoltà 5

> Qual è la differenza tra aggregazione e composizione in UML:
- aggregazione dipende dalla classe principale
- aggregazione definisce un comportamento dinamico
- **aggregazione ha ciclo di vita indipendente; composizione è dipendente** ✅
- composizione permette solo collegamenti temporanei

> Cosa rappresenta una dipendenza in UML:
- un collegamento debole tra due elementi
- **un ciclo di vita condiviso tra due oggetti** ✅
- un'operazione tra due classi
- un'ereditarietà tra due oggetti

---
## Diagrammi di sequenza

### Difficoltà 2

> Quale operatore viene utilizzato per rappresentare un ciclo in un diagramma di sequenza:
- **loop** ✅
- par
- opt
- alt

> Come viene rappresentato un messaggio sincrono in un diagramma di sequenza:
- freccia continua con testa vuota
- **freccia continua con testa piena** ✅
- freccia con testa rotonda
- freccia tratteggiata con testa vuota

> Quale tipo di messaggio consente al mittente di continuare l'esecuzione senza aspettare una risposta:
- sincrono
- bloccante
- sincronizzato
- **asincrono** ✅

> Che cosa rappresenta una lifeline in un diagramma di sequenza:
- **la durata della vita di un oggetto** ✅
- un messaggio asincrono
- un messaggio sincrono
- una comunicazione tra oggetti

> Quale elemento mostra un messaggio di ritorno in un diagramma di sequenza:
- freccia continua con testa vuota
- **freccia tratteggiata con testa vuota** ✅
- freccia con testa rotonda
- freccia continua con testa piena

### Difficoltà 3

> Quale simbolo viene usato per mostrare la creazione di un partecipante:
- **una freccia continua che entra nella box del partecipante** ✅
- una freccia con una X
- una linea tratteggiata
- un'icona di oggetto

> Quando viene usato l'operatore alt nei diagrammi di sequenza:
- per definire una regione critica
- per definire un messaggio asincrono
- **per definire una condizione alternativa** ✅
- per definire un ciclo

> Che cosa rappresenta una X alla fine di una lifeline:
- **la cancellazione di un partecipante** ✅
- un errore di comunicazione
- la fine di un ciclo
- l'inizio di un messaggio

### Difficoltà 4

> Qual è lo scopo principale dei diagrammi di sequenza:
- mostrare la struttura statica del sistema
- descrivere il flusso di controllo
- mostrare la gerarchia di oggetti
- **mostrare la interazione tra oggetti** ✅

> Qual è lo scopo dei frame nei diagrammi di sequenza:
- **rappresentare condizioni, cicli o operazioni parallele** ✅
- separare le interazioni in base al tipo di oggetto
- mostrare la sequenza di oggetti nel tempo
- indicare la fine di un messaggio

---
## Diagrammi di package e di deployment

### Difficoltà 2

> Come viene mostrata la gerarchia nei diagrammi di package:
- con linee tratteggiate
- con linee continue
- **con package annidati** ✅
- con frecce

### Difficoltà 3

> Qual è il ruolo principale dei diagrammi di package in UML:
- mostrare la struttura fisica di un sistema
- descrivere il comportamento dinamico
- **organizzare logicamente elementi correlati** ✅
- definire il flusso di controllo

> Che cosa rappresenta un nodo in un diagramma di deployment:
- un messaggio tra oggetti
- un'interfaccia
- **un elemento hardware o software** ✅
- un'istanza di una classe

> Cosa rappresenta un package in UML:
- un elemento che definisce la struttura fisica di un sistema
- un'istanza di una classe
- un elemento di controllo
- **un raggruppamento logico di elementi** ✅

> Quale elemento nei diagrammi di deployment rappresenta un ambiente di esecuzione:
- un artefatto
- un componente
- un'istanza
- **un nodo** ✅

### Difficoltà 4

> Qual è lo scopo di un template package:
- creare oggetti a runtime
- **definire una struttura generica riutilizzabile** ✅
- definire una gerarchia tra classi
- mostrare il comportamento dinamico del sistema

### Difficoltà 5

> Qual è la relazione tra artefatti e componenti nei diagrammi di deployment UML 2.x:
- **gli artefatti implementano i componenti** ✅
- gli artefatti dipendono dai componenti
- non esiste relazione diretta
- i componenti implementano gli artefatti

> Quale keyword viene utilizzata per un'importazione privata in UML:
- public
- private
- import
- **access** ✅

> Come viene rappresentato un'artefatto in un diagramma di deployment:
- con un cerchio
- con una linea continua
- con una freccia
- **anche con un'icona di documento** ✅

> Che cos'è una dipendenza in UML:
- un elemento che mostra lo stato di un oggetto
- **una relazione che indica che un elemento dipende da un altro** ✅
- una relazione tra oggetti
- un'interfaccia tra classi

---
## Casi d'uso

### Difficoltà 1

> Perché è consigliato mantenere i casi d'uso brevi e leggibili:
- per limitare l'interazione utente
- per nascondere i dettagli al cliente
- **perché quelli troppo lunghi non vengono letti** ✅
- per evitare errori nel codice

### Difficoltà 2

> Che cosa rappresenta un attore in un caso d'uso UML:
- un modulo software interno
- **un ruolo assunto da un'entità esterna che interagisce con il sistema** ✅
- un'interfaccia utente grafica
- una classe interna al sistema

> A cosa servono le estensioni in un caso d'uso:
- a elencare tutti gli attori
- a definire il database del sistema
- **a rappresentare flussi alternativi rispetto allo scenario principale** ✅
- a mostrare l'interfaccia utente

> Quale delle seguenti è una caratteristica di un attore:
- controlla i casi d'uso interni
- **è esterno al sistema e rappresenta un ruolo** ✅
- risiede all'interno del confine del sistema
- è sempre un componente software

> Cosa indica la pre-condizione in un caso d'uso:
- **una condizione che deve essere vera prima di iniziare il caso d'uso** ✅
- un messaggio di errore
- l'interfaccia utente da utilizzare
- il risultato previsto

### Difficoltà 3

> Cosa rappresenta il 'subject' in un diagramma di casi d'uso UML:
- **il confine del sistema** ✅
- un attore secondario
- una funzione opzionale
- un caso d'uso esteso

> Qual è la rappresentazione grafica corretta della relazione «include» in UML:
- **freccia tratteggiata con punta vuota e keyword «include»** ✅
- doppia linea tratteggiata
- linea continua con freccia piena
- freccia con keyword «extend»

### Difficoltà 4

> qual è l'obiettivo principale di uno scenario principale di successo (MSS):
- **descrivere un'interazione completa e positiva tra attore e sistema** ✅
- elencare i requisiti tecnici del sistema
- evidenziare i malfunzionamenti
- rappresentare i ruoli amministrativi

> Cosa distingue un 'business use case' da un 'system use case':
- il system use case si riferisce a più sistemi aziendali
- il business use case riguarda solo gli utenti interni
- **il business use case si concentra sui processi aziendali e non dipende da uno specifico sistema** ✅
- il business use case è più dettagliato

### Difficoltà 5

> Quando viene eseguito un caso d'uso incluso:
- **sempre, come parte integrante del caso includente** ✅
- solo in presenza di condizioni
- quando il sistema lo consente
- solo su richiesta dell'attore

---
## Diagrammi di macchina a stati

### Difficoltà 2

> Qual è uno degli elementi chiave delle macchine a stati UML:
- oggetto
- **transizione** ✅
- classe
- attributo

> Cosa rappresenta graficamente uno stato iniziale in UML:
- un rombo tratteggiato
- un rettangolo
- **un cerchio pieno nero** ✅
- un cerchio con H

> Qual è il simbolo utilizzato per rappresentare un invio di segnale:
- **pentagono convesso** ✅
- cerchio pieno
- rettangolo tratteggiato
- pentagono concavo

### Difficoltà 3

> Cosa rappresenta uno pseudostato di giunzione:
- **un punto di unione o diramazione** ✅
- un punto di ingresso
- un'attività
- una transizione temporale

> Quale tra i seguenti è un tipo di evento UML:
- data event
- class event
- **signal event** ✅
- flow event

> Cosa rappresenta un punto di uscita (exit point):
- un'azione interrotta
- una transizione condizionale
- un evento asincrono
- **un punto di uscita da uno stato composito** ✅

> Quando si attiva un change event:
- quando un segnale è ricevuto
- quando cambia il tipo dell'oggetto
- quando si riceve un comando utente
- **quando un'espressione booleana passa da falso a vero** ✅

### Difficoltà 4

> Quale vantaggio offrono gli stati compositi ortogonali:
- **permettono l'esecuzione concorrente** ✅
- rendono più astratto il diagramma
- permettono il riuso del codice
- riducono gli eventi

### Difficoltà 5

> Qual è la differenza tra un'azione e un'attività in uno stato:
- le azioni sono asincrone
- le attività sono istantanee
- le attività sono in ingresso
- **le azioni sono atomiche** ✅

> Quale condizione è richiesta affinché una transizione automatica si attivi:
- un segnale
- **una condizione di guardia vera** ✅
- una classe di contesto
- un evento

---
## Diagrammi di attività

### Difficoltà 2

> Qual è la funzione principale di un diagramma di attività UML:
- **rappresentare il flusso di controllo o il flusso di oggetti in un sistema** ✅
- definire la gerarchia dei casi d'uso
- mostrare la comunicazione tra oggetti
- descrivere la struttura statica delle classi

> Cosa rappresenta un 'merge' in un diagramma di attività:
- una condizione temporale
- l'inizio di una nuova attività
- **un punto in cui più flussi convergono in uno solo** ✅
- una partizione di responsabilità

### Difficoltà 3

> Cosa rappresenta un 'fork' in un diagramma di attività:
- un collegamento a un altro diagramma
- una condizione che attiva un'unica azione
- una rappresentazione grafica di un segnale
- **un nodo che divide il flusso in azioni parallele** ✅

> Cosa sono le 'swim lanes' in un diagramma di attività:
- sezioni che indicano cicli infiniti
- **partizioni che mostrano quale attore esegue ciascuna azione** ✅
- flussi condizionati tra attività parallele
- linee che separano attività temporali

> Cosa rappresenta un 'flow final' in un diagramma di attività:
- la chiusura dell'intera attività
- **la fine di un singolo flusso senza terminare l'intera attività** ✅
- un punto di partenza alternativo
- un controllo di concorrenza

> Come può essere visualizzato il passaggio di oggetti tra azioni:
- attraverso un fork
- con un nodo decisionale
- **utilizzando riquadri di classe o pin** ✅
- solo tramite note testuali

### Difficoltà 4

> Quando un nodo di azione viene eseguito secondo la semantica dei token:
- appena riceve un qualsiasi token
- **quando riceve token su tutti i flussi in ingresso e le precondizioni sono soddisfatte** ✅
- solo alla fine del processo
- quando tutte le azioni precedenti sono terminate

> Qual è lo scopo di una 'expansion region':
- separare i diagrammi in partizioni logiche
- definire un ciclo infinito di attività
- mostrare la concorrenza implicita nei nodi
- **eseguire una sequenza di azioni per ogni elemento di una collezione** ✅

> A cosa serve una 'join specification':
- stabilire una connessione tra due attività
- rappresentare un ciclo
- **definire condizioni booleane per la sincronizzazione dei flussi** ✅
- mostrare la concorrenza implicita

### Difficoltà 5

> Che cos'è un 'pin' in un diagramma di attività:
- una condizione di attivazione
- un connettore tra due diagrammi
- un nodo di sincronizzazione temporale
- **un indicatore dei parametri di input/output di un'azione** ✅

---
## Comunicazione, strutture e componenti

### Difficoltà 2

> Qual è la principale differenza tra un diagramma di comunicazione e un diagramma di sequenza:
- **il primo enfatizza i collegamenti tra oggetti** ✅
- il secondo mostra solo le interazioni
- il secondo non è parte di UML
- il primo mostra solo la sequenza temporale

### Difficoltà 3

> Quale affermazione è vera sui diagrammi delle componenti in UML:
- non possono essere usati per architetture orientate ai servizi
- mostrano solo classi e interfacce
- sono equivalenti ai diagrammi delle classi
- **rappresentano la scomposizione logica di un sistema in unità modulari** ✅

> Quando è preferibile usare un diagramma di comunicazione:
- quando si ha una logica di controllo complessa
- quando si lavora con sistemi embedded
- **quando si vogliono mostrare i collegamenti tra partecipanti** ✅
- quando si vuole enfatizzare l'ordine dei messaggi

### Difficoltà 4

> Che cos'è un'interfaccia fornita in UML:
- una classe concreta con metodi pubblici
- una classe astratta specializzata
- **un'interfaccia che una classe implementa per offrire servizi** ✅
- un'interfaccia richiesta da una classe

> Qual è la differenza principale tra classe astratta e interfaccia in UML:
- le classi astratte non possono avere metodi
- **le interfacce non hanno implementazioni** ✅
- le interfacce possono avere attributi
- le interfacce si usano solo nei diagrammi delle classi

> Cosa consente di rappresentare un diagramma delle strutture composite:
- le dipendenze tra package
- il flusso dei messaggi tra oggetti
- **la decomposizione interna di una classe** ✅
- la sequenza di operazioni

> Come si rappresenta una porta in un diagramma di struttura composita:
- con un rettangolo
- **con un simbolo posizionato sul bordo dell'elemento** ✅
- con un cerchio pieno
- con una linea tratteggiata

> Cosa rappresenta la manifestazione nei diagrammi dei componenti:
- un'istanza di un componente
- **una relazione di dipendenza da un artefatto verso un elemento del modello** ✅
- un comportamento alternativo
- una sequenza di eventi

> Perché le strutture composite sono considerate runtime e non compile-time:
- perché sono legate ai pacchetti
- **perché modellano l'organizzazione interna a tempo di esecuzione** ✅
- perché rappresentano oggetti fisici
- perché usano attributi dinamici

### Difficoltà 5

> Cosa rappresenta l'espressione "*//" in un diagramma di comunicazione:
- interazione asincrona
- iterazione condizionata
- iterazione in ordine casuale
- **iterazione in parallelo** ✅

---
## Collaborazione, interazione generale e temporizzazione

### Difficoltà 2

> Cosa rappresentano principalmente i diagrammi di collaborazione in UML:
- i flussi di dati
- **l'interazione tra oggetti secondo ruoli e responsabilità** ✅
- i vincoli temporali tra eventi
- la struttura interna delle classi

### Difficoltà 3

> Quale vantaggio offrono i diagrammi di collaborazione rispetto ad altri diagrammi di interazione:
- sono più dettagliati nei vincoli temporali
- **sono più efficaci nella rappresentazione dei ruoli** ✅
- supportano le classi astratte
- riducono la complessità strutturale

> A cosa servono i diagrammi di interazione generale:
- a rappresentare le interazioni in forma tabellare
- a visualizzare oggetti in tempo reale
- a definire l'architettura hardware
- **a fornire una vista panoramica del flusso tra diagrammi di interazione** ✅

> Cosa rappresenta ciascun nodo in un diagramma di interazione generale:
- una collaborazione tra package
- una classe astratta
- una fase di compilazione
- **un sotto-diagramma di interazione** ✅

> Cosa si rappresenta sull'asse verticale di un Timing diagram:
- **gli stati o attributi di un oggetto** ✅
- il tempo
- le istanze di classi
- i messaggi asincroni

### Difficoltà 4

> Cosa si intende per occorrenza di collaborazione in UML:
- una classe astratta che implementa un'interfaccia
- una vista statica dei componenti
- una relazione tra due package
- **un uso concreto di una collaborazione in un contesto specifico** ✅

> Qual è la principale utilità dei Timing diagrams:
- rappresentare package e componenti
- mostrare la struttura interna delle classi
- gestire la concorrenza tra thread
- **descrivere vincoli temporali su stati o eventi** ✅

> In quale contesto i Timing diagrams risultano particolarmente utili:
- nella progettazione orientata agli oggetti
- **in sistemi con vincoli temporali stringenti** ✅
- nella modellazione di classi generiche
- in applicazioni con forte modularità

> Cosa accomuna i tre tipi di diagrammi trattati nella lezione:
- **supportano la modellazione del comportamento dinamico del sistema** ✅
- sono focalizzati sulla rappresentazione dei dati
- utilizzano solo classi astratte
- sono diagrammi statici

### Difficoltà 5

> Quando una collaborazione è considerata riusabile:
- quando non include istanze
- quando viene definita come oggetto runtime
- **quando ha ruoli generici ma ben definiti** ✅
- quando è priva di interfacce

---
## Elicitazione dei requisiti: Introduzione e concetti chiave

### Difficoltà 1

> In quale caso è preferibile usare un wireframe low-fidelity:
- durante la fase di test
- nella manutenzione evolutiva
- **nelle fasi preliminari di progetto** ✅
- durante il collaudo

### Difficoltà 2

> Qual è uno degli obiettivi principali dell'elicitazione dei requisiti:
- raccogliere suggerimenti dagli sviluppatori
- eliminare tutte le ambiguità di progetto
- **definire chiaramente cosa il sistema deve fare** ✅
- individuare i vincoli tecnologici prima di ogni altra cosa

> Quando le interviste sono particolarmente utili durante l'elicitazione:
- quando si vuole raccogliere statistiche
- **quando è necessario un confronto personale e approfondito** ✅
- quando si lavora in team remoti
- quando si vogliono testare i prototipi

> Cosa caratterizza un workshop efficace per l'elicitazione:
- uso esclusivo di strumenti digitali
- **partecipazione simultanea di più stakeholder** ✅
- durata superiore a due ore
- presenza di documentazione formale

> Cosa rende utile il Greenfield Engineering:
- la revisione del codice esistente
- la simulazione di interfacce
- **lo sviluppo da zero senza vincoli preesistenti** ✅
- l'integrazione con sistemi legacy

> Cosa si intende per problem statement:
- una lista dei componenti software
- una sequenza di task da automatizzare
- **una descrizione chiara del problema da risolvere** ✅
- un documento per la validazione

### Difficoltà 3

> Cosa può causare una comunicazione inefficace tra stakeholder e sviluppatori:
- un eccesso di documentazione tecnica
- l'uso di strumenti di prototipazione avanzata
- **la mancata comprensione reciproca** ✅
- la presenza di troppi stakeholder

> Cosa distingue la prototipazione throw-away:
- usa wireframe ad alta fedeltà
- **i prototipi vengono scartati dopo il feedback** ✅
- è utilizzata solo per testare interfacce
- è adatta solo a progetti agili

> Qual è una sfida tipica nel Reengineering:
- **assenza di documentazione aggiornata** ✅
- definizione degli stakeholder iniziali
- creazione di mockup interattivi
- uso di wireframe low-fidelity

> Qual è uno dei vantaggi del wireframe high-fidelity:
- facilità di produzione
- **alta interazione con l'utente** ✅
- uso in brainstorming
- rapidità di sviluppo

---
## Elicitazione dei requisiti: Attività principali

### Difficoltà 2

> Qual è l'obiettivo principale dell'identificazione degli attori:
- comprendere i vincoli tecnologici e normativi
- **definire i confini del sistema e le interazioni principali** ✅
- stabilire le priorità dei requisiti non funzionali
- organizzare il team di sviluppo

> Che ruolo ha un attore nella modellazione dei requisiti:
- rappresentare una funzionalità interna del sistema
- verificare le performance dell'architettura
- **rappresentare qualsiasi entità esterna che interagisce con il sistema** ✅
- gestire la sicurezza delle interfacce

> Cosa descrivono i requisiti funzionali:
- monitorare le metriche aziendali
- progettare l'interfaccia utente
- **le funzionalità che il sistema deve offrire** ✅
- controllare il budget di progetto

> Perché è importante distinguere tra attore e persona:
- progettare l'interfaccia utente
- monitorare le metriche aziendali
- controllare il budget di progetto
- **perché un attore rappresenta un ruolo e non un individuo** ✅

> Un attore può essere anche un altro sistema informatico:
- solo se è gestito da un utente
- solo se interagisce via interfaccia grafica
- **sì, se interagisce con il sistema** ✅
- no, solo utenti umani possono esserlo

> I casi d'uso devono evitare la descrizione dell'interfaccia utente:
- **sì, per concentrarsi sulle azioni** ✅
- no, perché è utile per il design
- solo quando si tratta di prototipi
- mai, l'interfaccia è sempre inclusa

### Difficoltà 3

> Gli scenari As-is descrivono la situazione attuale del sistema:
- per supportare i nuovi utenti
- **per osservare e documentare l'uso attuale** ✅
- per ispirare requisiti futuri
- per facilitare il test del sistema

> I requisiti non funzionali rispondono alla domanda su come si comporta il sistema:
- no, servono solo per il marketing
- **sì, specificano qualità e vincoli** ✅
- sì, ma solo in fase di collaudo
- no, indicano solo cosa fa il sistema

### Difficoltà 5

> Che cosa specificano i requisiti non funzionali:
- **come il sistema deve comportarsi** ✅
- progettare l'interfaccia utente
- controllare il budget di progetto
- monitorare le metriche aziendali

> Quale scenario è utile per valutare il sistema in fase di test:
- **evaluation scenario** ✅
- controllare il budget di progetto
- monitorare le metriche aziendali
- progettare l'interfaccia utente

---
## Gestione del processo di specifica dei requisiti

### Difficoltà 2

> Il metodo JAD prevede la partecipazione attiva di tutti gli stakeholder durante:
- **le sessioni intensive di lavoro per la negoziazione delle specifiche** ✅
- l'esecuzione dei test funzionali
- la stesura autonoma del documento dei requisiti da parte degli sviluppatori
- il rilascio finale del software

> Uno degli obiettivi principali della documentazione dei requisiti è:
- **fornire una base condivisa e verificabile nel tempo** ✅
- rendere opzionali i test di validazione
- sostituire la comunicazione diretta tra stakeholder
- ridurre i tempi di rilascio del software

> Una matrice di tracciabilità collega:
- le attività del team con i documenti fiscali
- **i requisiti con use case, componenti e test** ✅
- gli stakeholder con i fornitori
- le spese di progetto con le fatture

### Difficoltà 3

> Nel documento RAD, la sezione 'Sistema corrente' serve a:
- **documentare problemi e inefficienze esistenti** ✅
- introdurre il contesto del sistema proposto
- descrivere il flusso di sviluppo del software
- spiegare le metodologie di testing adottate

> Uno dei principali vantaggi della tracciabilità è:
- limitare l'accesso degli utenti al sistema
- **mantenere il controllo sul cambiamento** ✅
- semplificare la struttura dei database
- automatizzare le attività di manutenzione hardware

> Tra i requisiti non funzionali documentabili troviamo:
- **le prestazioni, l'usabilità e la sicurezza** ✅
- le condizioni di consegna dei prodotti
- la lista dei fornitori
- le ore lavorate da ciascun sviluppatore

> Il requisito 'caricamento delle pagine in meno di 2 secondi' è un esempio di:
- **requisito non funzionale** ✅
- vincolo contrattuale
- requisito funzionale
- strategia di marketing

### Difficoltà 4

> Il documento finale di una sessione JAD viene:
- scritto solo dagli sviluppatori
- **approvato dagli stakeholder in una riunione finale** ✅
- inviato automaticamente al cliente
- utilizzato esclusivamente dai tester

> Un mock-up nel RAD è utile per:
- generare codice sorgente automatico
- scrivere report economici
- **validare precocemente la user experience** ✅
- testare performance server

### Difficoltà 5

> La forward traceability permette di tracciare un requisito verso:
- gli stakeholder che lo hanno proposto
- le modifiche successive della documentazione
- **il design, l'implementazione e i test** ✅
- il contesto aziendale e normativo

---
## Analisi dei requisiti e modellazione a oggetti

### Difficoltà 2

> L'analisi dei requisiti consente di chiarire le specifiche raccolte:
- attraverso la comunicazione informale
- **formalizzandole in modelli tecnici e condivisi** ✅
- usando strumenti di programmazione
- eliminando ogni ambiguità a mano libera

> La comunicazione tra utenti e sviluppatori è efficace se:
- **è supportata da modelli condivisi** ✅
- si limita a una fase iniziale
- è basata su email informali
- avviene dopo l'implementazione

> Gli oggetti entity sono caratterizzati da:
- interazioni occasionali con gli utenti
- **dati significativi e persistenti** ✅
- funzioni di presentazione grafica
- logiche di controllo temporanee

> Gli oggetti boundary gestiscono:
- le classi astratte
- la logica di business
- **le interfacce con l'esterno** ✅
- le connessioni di rete

> Il class diagram rappresenta:
- le transizioni tra stati di un oggetto
- **la struttura statica del sistema** ✅
- il flusso di dati tra componenti
- le interazioni sequenziali

> Lo state machine diagram mostra:
- gli attributi delle classi
- **le transizioni tra stati** ✅
- le connessioni di rete
- le interfacce grafiche

> La composizione tra classi implica che:
- una classe dipende dalla rete
- una classe eredita da un'altra
- **una classe contiene un'altra** ✅
- una classe rappresenta un attore

### Difficoltà 3

> Gli oggetti control hanno il compito di:
- mostrare dati all'utente
- memorizzare dati nel database
- **gestire il flusso dei casi d'uso** ✅
- connettere dispositivi esterni

> Il sequence diagram rappresenta:
- le classi e i loro metodi
- gli stati di un oggetto
- il flusso di attività tra moduli
- **lo scambio di messaggi tra oggetti** ✅

### Difficoltà 4

> L'activity diagram è utile per:
- descrivere lo stato di un oggetto
- **modellare processi complessi e concorrenti** ✅
- identificare entità persistenti
- determinare la classe principale

---
## Attività principali dell'analisi dei requisiti

### Difficoltà 2

> Qual è il ruolo principale degli oggetti control:
- contenere dati del dominio
- agire come interfaccia con l'utente
- **orchestrare il comportamento del sistema** ✅
- rappresentare attributi interni

> Cosa indicano le frasi passive nell'analisi di Abbott:
- classi da evitare
- **collaborazioni tra oggetti** ✅
- nomi degli attributi
- relazioni statiche

> Qual è un esempio di relazione di tipo associazione:
- **cliente effettua ordine** ✅
- ordine compone righeOrdine
- catalogo aggrega prodotti
- fattura compone vociFattura

### Difficoltà 3

> Quale tra i seguenti oggetti rappresenta un oggetto boundary nel sistema e-commerce:
- **paginaLoginForm** ✅
- ordine
- prodotto
- gestionePagamentoControl

> Secondo Abbott, cosa suggeriscono i verbi in un testo analizzato:
- **metodi o relazioni** ✅
- attributi delle classi
- collaborazioni tra oggetti
- candidati a diventare classi

> Cosa rappresenta una generalizzazione in UML:
- una classe con responsabilità
- una freccia con punta piena
- una relazione tra oggetti indipendenti
- **una freccia triangolare dalla sottoclasse alla superclasse** ✅

> Cosa rappresentano i collaboratori in una scheda CRC:
- **le classi con cui una classe interagisce** ✅
- i vincoli del sistema
- i dati interni della classe
- i metodi ereditati

### Difficoltà 4

> Qual è una caratteristica di un oggetto entity:
- rappresenta l'aspetto grafico
- viene creato e distrutto in ogni caso d'uso
- **persiste oltre la singola interazione** ✅
- orchestra le interazioni

> Cosa rappresenta una composizione in UML:
- una dipendenza debole tra oggetti
- una relazione tra oggetti con esistenza indipendente
- **una relazione parte-tutto con vincolo di esistenza** ✅
- una generalizzazione tra classi

### Difficoltà 5

> Cosa distingue una composizione da un'aggregazione:
- la composizione è rappresentata con un rombo vuoto
- la parte in una composizione può esistere indipendentemente
- l'aggregazione non ha vincoli tra oggetti
- **la composizione implica la dipendenza esistenziale della parte** ✅

---
## Gestione del processo di analisi dei requisiti

### Difficoltà 1

> La sezione Object Models del RAD documenta:
- **gli oggetti e le loro relazioni** ✅
- gli scenari e i casi d'uso
- diagrammi delle attività
- diagrammi di stato

### Difficoltà 2

> Il RAD descrive il sistema in modo:
- **completo e comprensibile** ✅
- modulare e astratto
- informale e sintetico
- limitato e descrittivo

> Il revisore ideale è una persona che:
- ha partecipato a tutte le fasi del progetto
- **è esterna al progetto** ✅
- ha scritto il RAD
- fa parte del team di sviluppo

> Il RAD deve essere mantenuto:
- offline in versione PDF
- archiviato solo su cartaceo
- pubblico su social media
- **aggiornato e condiviso online** ✅

> Un buon RAD consente di:
- ignorare le revisioni
- rivedere velocemente il budget
- **mantenere coerenza e tracciabilità** ✅
- limitare l'interazione tra i team

### Difficoltà 3

> Il RAD viene congelato come:
- schema provvisorio
- proposta iniziale
- **baseline** ✅
- test finale

> Un requisito ad alta priorità deve essere:
- trascurabile nella prima versione
- **presente nella prima versione** ✅
- escluso dal RAD
- implementato in fase avanzata

### Difficoltà 4

> Le modifiche dopo il sign-off devono essere:
- **gestite con rigore** ✅
- concordate solo con il cliente
- approvate solo dai tecnici
- comunicate informalmente

> La fase di maturità del modello implica che il modello sia:
- modificabile solo da stakeholder
- **stabile e con modifiche limitate** ✅
- creato dal revisore esterno
- generato in automatico

> Un cambiamento proposto dopo il client sign-off deve essere:
- **analizzato nel suo impatto** ✅
- validato senza documentazione
- evitato a ogni costo
- approvato verbalmente

---
## Progettazione di interfacce grafiche

### Difficoltà 2

> I path navigazionali:
- descrivono comportamenti visivi
- identificano le funzioni più usate
- indicano il layout visivo dell'interfaccia
- **mostrano le scelte logiche e i punti decisionali** ✅

> La progettazione dell'interfaccia:
- si limita alla scelta dei colori
- **serve a tradurre i requisiti in soluzioni visive** ✅
- si concentra solo sul layout grafico
- viene utilizzata solo per creare prototipi finali

> La possibilità di annullare un'azione:
- favorisce l'ansia da errore
- **rende reversibili operazioni comuni** ✅
- impedisce la sperimentazione
- riduce la personalizzazione

> Il principio di visibilità:
- nasconde funzioni non utilizzate
- riduce l'efficienza del sistema
- **aiuta l'utente a capire cosa può fare** ✅
- elimina i controlli ridondanti

### Difficoltà 3

> Il design estetico e minimalista:
- **elimina elementi superflui e distraenti** ✅
- introduce decorazioni visive complesse
- aggiunge elementi informativi ridondanti
- riduce la funzionalità dell'interfaccia

### Difficoltà 4

> I mock-up a bassa fedeltà:
- richiedono strumenti avanzati
- sono rappresentazioni interattive
- non aiutano a esplorare alternative progettuali
- **permettono revisioni rapide e flessibili** ✅

> Offrire scorciatoie per utenti esperti:
- complica l'interazione per i principianti
- rende l'interfaccia meno accessibile
- impone modalità operative complesse
- **consente l'uso rapido di funzionalità frequenti** ✅

> Un buon feedback informativo:
- elimina la necessità di messaggi
- riduce l'interazione visiva
- **rafforza il controllo e la fiducia** ✅
- sostituisce le notifiche testuali

### Difficoltà 5

> Il principio del riconoscimento più che memorizzazione:
- impone di ricordare passaggi precedenti
- richiede l'uso della memoria operativa
- si applica solo in interfacce mobili
- **offre informazioni visibili e facilmente accessibili** ✅

> Il concetto di affordance:
- impone l'uso di istruzioni dettagliate
- nasconde l'intenzione funzionale
- **usa forme che invitano all'azione corretta** ✅
- indica comportamenti futuri del sistema

---
## Introduzione al System Design

### Difficoltà 2

> Il design modulare consente di:
- aumentare l'accoppiamento tra componenti
- **favorire il riutilizzo e la manutenibilità** ✅
- difficoltare il lavoro in team
- impedire la parallelizzazione del lavoro

> Un errore comune nel System Design è:
- documentare eccessivamente il progetto
- posticipare le decisioni tecnologiche
- **iniziare la codifica senza progettazione** ✅
- valutare i requisiti prima dell'analisi

> Una buona decomposizione in sottosistemi prevede che:
- i componenti abbiano molte dipendenze reciproche
- **ogni modulo abbia compiti ben definiti** ✅
- le responsabilità siano distribuite casualmente
- tutti i moduli condividano i dati globali

> Nel System Design, i design goals sono:
- descrizioni dei casi d'uso
- vincoli hardware imposti dal cliente
- nomi delle librerie da utilizzare
- **qualità da ottimizzare nella progettazione** ✅

### Difficoltà 3

> Il System Design permette di:
- **tradurre i requisiti in architettura tecnica** ✅
- definire il layout grafico dell'interfaccia
- testare il software in fase finale
- documentare il ciclo di vita del software

> Il principio di low coupling implica che:
- i sottosistemi dipendano il più possibile tra loro
- le interfacce siano complesse e dettagliate
- tutti i componenti usino gli stessi dati
- **ogni modulo possa evolvere indipendentemente** ✅

> Un approccio iterativo consente di:
- **correggere gli errori a costi ridotti** ✅
- testare il software a progetto completato
- ridurre l'efficacia delle prime versioni
- definire i dettagli implementativi subito

> Il design dovrebbe essere guidato da:
- tecnologie disponibili
- **obiettivi e vincoli espliciti** ✅
- esperienze personali
- moda del momento

> Una scelta architetturale prematura può:
- **limitare la flessibilità del sistema** ✅
- favorire l'evoluzione futura
- ridurre i costi iniziali
- facilitare il testing

### Difficoltà 4

> La gestione delle condizioni limite nel System Design comprende:
- l'analisi dei costi del progetto
- la scrittura dei test unitari
- **la configurazione iniziale, avvio e recupero da errori** ✅
- la definizione del layout utente

---
## System Design: Concetti principali

### Difficoltà 2

> Il concetto di sottosistema nell'ambito del system design si riferisce a:
- **una parte indipendente del sistema con responsabilità funzionali** ✅
- un modulo accessorio
- una metodologia di test
- un'interfaccia grafica

> Una classe nella progettazione orientata agli oggetti rappresenta:
- un gruppo di sviluppatori
- un insieme di test
- **un'entità con stato e comportamento** ✅
- una specifica hardware

> La coesione è definita come:
- velocità di esecuzione del codice
- quantità di interfacce
- **grado di collaborazione interna di un modulo** ✅
- interdipendenza tra moduli

> Una buona pratica progettuale consiste nell'avere:
- **alta coesione e basso accoppiamento** ✅
- bassa coesione e alto accoppiamento
- bassa coesione e basso accoppiamento
- alta coesione e alto accoppiamento

> Il partizionamento è:
- una modalità di accesso ai dati
- una tecnica di testing
- suddivisione gerarchica in livelli
- **suddivisione orizzontale in moduli funzionali indipendenti** ✅

### Difficoltà 3

> La decomposizione in sottosistemi:
- aumenta la complessità
- **favorisce l'indipendenza e la modularità** ✅
- riduce la documentazione
- richiede meno risorse

> Un servizio di un sottosistema è:
- un modulo opzionale
- una funzione interna non documentata
- un protocollo di rete
- **un insieme di operazioni correlate esposte ad altri sottosistemi** ✅

> Un elevato accoppiamento tra moduli comporta:
- codice più efficiente
- facile sostituzione dei moduli
- maggiore manutenibilità
- **alta interdipendenza e difficoltà nella modifica** ✅

> In una stratificazione chiusa:
- un livello accede direttamente a quelli superiori
- **ogni livello comunica solo con il livello inferiore** ✅
- i livelli non hanno dipendenze
- tutti i livelli sono intercambiabili

### Difficoltà 5

> Una stratificazione opaca è preferibile:
- per sistemi semplici
- **quando serve indipendenza tra livelli** ✅
- quando non ci sono interfacce
- quando è richiesta massima flessibilità

---
## System Design: Dagli oggetti ai sottosistemi

### Difficoltà 2

> Per identificare i sottosistemi correttamente bisogna:
- minimizzare la coesione
- **usare casi d'uso come base** ✅
- ignorare le dipendenze
- unire moduli con responsabilità diverse

> Per trade-off si intende:
- un tipo di sottosistema
- un obiettivo di design secondario
- **un compromesso tra criteri** ✅
- un linguaggio di programmazione

### Difficoltà 3

> La modularità:
- aumenta l'accoppiamento
- **favorisce il riutilizzo** ✅
- riduce la leggibilità
- complica la manutenzione

> Un sottosistema è caratterizzato da:
- accesso diretto ai dati
- scarsa autonomia
- logica dispersa
- **un'interfaccia pubblica e oggetti coesi** ✅

> Sottosistemi ben progettati offrono:
- maggior complessità
- dipendenze strette
- **facilità di sostituzione** ✅
- difficoltà di modifica

> Gli obiettivi di design rappresentano:
- **le priorità architetturali** ✅
- le funzionalità del sistema
- i dati da elaborare
- i vincoli tecnici

### Difficoltà 4

> Per separazione delle responsabilità si intende:
- evitare test e manutenzione
- unire i dati in un unico livello
- accorpare la logica in un singolo modulo
- **isolare le aree funzionali** ✅

> I sottosistemi devono interagire tra essi:
- ssenza interfacce
- attraverso modifiche dirette
- con accessi diretti ai dati interni
- **attraverso interfacce pubbliche** ✅

> Quale dei seguenti è un criterio di performance:
- usabilità
- **tempo di risposta** ✅
- adattabilità
- costo di manutenzione

> La dependability misura:
- **disponibilità e sicurezza** ✅
- numero di utenti
- spazio su disco
- quantità di codice

---
## System Design: Obiettivi di Progettazione

### Difficoltà 2

> L'obiiettivo del controllo degli accessi è:
- eseguire script
- ottimizzare query
- comprimere dati
- **definire chi può fare cosa** ✅

> Uno degli svantaggi del controllo degli accessi ACL (access control list) è:
- facilità di uso
- supporto limitato
- **scarsa scalabilità** ✅
- sicurezza elevata

### Difficoltà 3

> Uno degli obiettivi principali del mappint hardware/software è:
- **assegnare sottosistemi ai nodi hardware** ✅
- scrivere codice HTML
- progettare l'interfaccia utente
- Ggdinamica

> Il controllo degli accessi RBAC si riferisce a:
- **controllo basato su ruoli** ✅
- controllo manuale
- controllo geografico
- controllo temporale

> Uno shutdown sicuro prevede:
- avvio di emergenza
- cancellazione dati
- **salvataggio dati e chiusura connessioni** ✅
- installazione patch

### Difficoltà 4

> In un deployment diagram i nodi rappresentano:
- eventi asincroni
- **dispositivi fisici o ambienti di esecuzione** ✅
- livelli di sicurezza
- sequenze operative

> Uno dei vantaggi del controllo basato su eventi è:
- controllo diretto delle risorse
- alta latenza
- codice più semplice
- **modularità e reattività** ✅

> I dati persistenti sono:
- dati di sessione
- dati in cache
- **dati che sopravvivono alla chiusura del sistema** ✅
- dati temporanei

### Difficoltà 5

> Il controllo basato su thread favorisce:
- supporto limitato
- **parallelismo elevato** ✅
- sincronia forzata
- semplicità

> Per rappresentare permessi in forma tabellare si utilizza:
- lista di utenti
- schema ER
- Foglio Excel
- **matrice degli accessi** ✅

---
## Gestione del processo di system design

### Difficoltà 2

> Il configuration manager:
- **gestisce le modifiche e versioni** ✅
- analizza i requisiti
- programma i test
- crea diagrammi UML

> La definizione esplicita dei ruoli:
- aumenta la complessità
- **evita disallineamenti** ✅
- riduce la documentazione
- accelera il deployment

> Lo scopo della design window è:
- limitare il testing
- **stabilire scadenze decisionali** ✅
- definire vincoli di budget
- bloccare la comunicazione

### Difficoltà 3

> Il responsabile della coerenza architetturale del sistema prende il nome di:
- Project manager
- **Architetto** ✅
- Cliente
- Sviluppatore

> La prototipazione è utile per:
- **testare le scelte architetturali** ✅
- ridurre il personale
- evitare il testing
- scrivere documenti

### Difficoltà 4

> Lo scopo principale del System Design Document (SDD) è:
- definire il linguaggio di programmazione
- descrivere le interfacce grafiche
- fornire una guida visiva al team
- **documentare le scelte progettuali** ✅

> Il compito principale dei liaison è:
- **comunicare tra team** ✅
- validare requisiti
- scrivere codice
- gestire il budget

> La comunicazione durante il design è complessa a causa di:
- pochi partecipanti
- assenza di documenti
- design immutabile
- **modifiche frequenti** ✅

> Quale tra i seguenti elementi ha lo scopo di evitare l'ambiguità terminologica:
- diagrammi
- **glossario** ✅
- test automatici
- checklist

### Difficoltà 5

> La qualità tecnica del SDD è verificata da:
- il venditore
- il document editor
- **il reviewer** ✅
- il cliente

---
## Introduzione all'object design

### Difficoltà 2

> Quale delle seguenti è una tecnica di riuso:
- **Ereditarietà** ✅
- Compressione
- Virtualizzazione
- Compilazione

> Il riuso:
- Aumenta la complessità
- Diminuisce la qualità
- Aumenta il rischio
- **Riduce tempi e costi** ✅

### Difficoltà 3

> L'object design è:
- **La fase che collega analisi e implementazione** ✅
- Un linguaggio di programmazione
- Un tipo di architettura software
- Una metodologia per testare software

> La delega rappresenta:
- Una metodologia di test
- **Una tecnica per evitare l'ereditarietà diretta** ✅
- Un tipo di commento nel codice
- Una libreria software

> I design pattern:
- Sono solo esempi di codice
- Servono solo per la documentazione
- **Forniscono soluzioni riusabili a problemi ricorrenti** ✅
- Non hanno un ruolo preciso

> La documentazione nel riuso:
- Aggiunge complessità
- Serve solo per gli auditor
- È opzionale
- **Conserva la conoscenza tecnica** ✅

### Difficoltà 4

> Il pattern Adapter:
- È un tipo di test automatico
- Genera report
- Semplifica solo l'interfaccia grafica
- **Implementa un'interfaccia e delega operazioni** ✅

> La tracciabilità nel riuso facilita:
- Refactoring continuo
- **Documentazione accurata** ✅
- Uso di pseudocodice
- Compilazione automatica

### Difficoltà 5

> Il Liskov Substitution Principle afferma che:
- Le interfacce sono opzionali
- **Un oggetto può sostituire un altro del suo tipo** ✅
- Le classi devono essere astratte
- Tutti gli oggetti sono intercambiabili

> Il configuration manager:
- Verifica i test
- **Gestisce versioni e dipendenze** ✅
- Disegna le interfacce
- Scrive il codice

---
## Specifica delle interfacce: concetti generali

### Difficoltà 2

> Qual è lo scopo principale della specifica delle interfacce:
- **definire un contratto tra oggetti che descrive le loro interazioni** ✅
- stabilire la grafica dell'interfaccia utente
- implementare direttamente la logica di business
- organizzare le classi per tipo di dati trattati

> Una firma di metodo ben progettata consente di:
- evitare del tutto la documentazione
- **intendere subito lo scopo del metodo** ✅
- nascondere il comportamento del metodo
- aumentare il numero di parametri

> Le precondizioni in una specifica di interfaccia servono a:
- descrivere l'interfaccia grafica del sistema
- nascondere i dettagli dell'implementazione
- **definire lo stato iniziale necessario per l'esecuzione del metodo** ✅
- stabilire l'output previsto del metodo

> L'implementatore della classe si occupa principalmente di:
- utilizzare i metodi pubblici da altre classi
- testare il comportamento degli oggetti
- creare la documentazione dei metodi
- **realizzare la logica interna della classe rispettando l'interfaccia** ✅

> L'estensore della classe ha il compito di:
- **creare sottoclassi che rispettino le regole della classe base** ✅
- modificare il codice sorgente originale della superclasse
- utilizzare solo metodi pubblici della classe base
- testare l'interfaccia con casi limite

### Difficoltà 3

> Il Single Responsibility Principle prevede che:
- una classe sia composta da più interfacce
- **una classe abbia una sola responsabilità ben definita** ✅
- una classe debba eseguire più operazioni correlate
- una classe non utilizzi metodi pubblici

> Un package ben progettato deve:
- essere accessibile da qualsiasi parte del sistema
- avere classi con responsabilità diverse tra loro
- **raggruppare classi coese e con obiettivi comuni** ✅
- contenere tutte le classi del progetto

> Un basso accoppiamento tra package favorisce:
- la dipendenza dai dettagli
- l'uso di variabili globali
- **l'indipendenza tra moduli** ✅
- la duplicazione del codice

### Difficoltà 4

> L'utente della classe:
- **utilizza la classe in altri moduli o contesti, senza modificarne né la struttura interna né il comportamento** ✅
- può modificare sia la struttura interna che il comportamento
- può modificare la struttura interna della classe ma non il comportamento
- può modificare il comportamento della classe ma non la struttura interna

> Il principio DIP (Dependency Inversion Principle) suggerisce che le classi debbano dipendere:
- da dettagli concreti
- **da interfacce astratte** ✅
- da variabili statiche
- dal sistema operativo

---
## Introduzione all'object design

### Difficoltà 1

> Il modificatore di visibilità 'pubblico' consente l'accesso:
- solo alle classi nel pacchetto
- solo alle classi figlie
- **a qualsiasi classe** ✅
- solo alla classe stessa

### Difficoltà 2

> L'identificazione degli attributi mancanti consente di:
- migliorare le prestazioni a runtime
- **colmare lacune del modello iniziale** ✅
- scrivere meno codice
- saltare la fase di testing

> Una postcondizione definisce:
- **le proprietà del sistema dopo l'esecuzione** ✅
- le condizioni che precedono un metodo
- i vincoli sull'input del metodo
- le classi che possono ereditare un metodo

> Per documentare una postcondizione in Javadoc si usa:
- **@return** ✅
- @param
- @example
- @throws

> Javadoc consente di integrare la documentazione:
- in un file separato
- solo nel manuale utente
- tramite un diagramma UML
- **all'interno del codice sorgente** ✅

### Difficoltà 3

> L'uso delle precondizioni in un contratto serve a specificare:
- quali eccezioni possono essere lanciate
- quali classi possono accedere a un metodo
- **cosa deve essere vero prima dell'esecuzione di un metodo** ✅
- il risultato atteso del metodo

> I contratti aiutano a:
- ridurre la documentazione
- evitare l'incapsulamento
- **rendere il comportamento esplicito** ✅
- nascondere le funzionalità

> Un invariante deve essere vero:
- **in ogni momento per ogni istanza** ✅
- prima dell'esecuzione di un metodo
- durante il deploy
- dopo ogni commit di codice

### Difficoltà 4

> L'uso di OCL consente di esprimere vincoli:
- con linguaggio imperativo
- **in modo formale e non ambiguo** ✅
- attraverso cicli e assegnazioni
- basandosi su esempi pratici

### Difficoltà 5

> Le invarianti in Javadoc sono:
- **inserite nella descrizione della classe** ✅
- descritte tramite @invariant
- non documentabili
- automaticamente verificate

---
## Gestione del processo di object design

### Difficoltà 2

> Il core architect è responsabile di:
- monitorare l'uso della memoria nei moduli runtime
- documentare le interfacce hardware
- **definire standard di codifica e linee guida** ✅
- testare i moduli di front-end

> Una delle finalità dell'ODD è:
- raccogliere feedback dai clienti
- gestire la configurazione del server
- ridurre l'uso della memoria
- **descrivere le interfacce pubbliche** ✅

> Il team di documentazione tecnica si occupa di:
- **rivedere la struttura e lo stile dell'ODD** ✅
- monitorare le prestazioni in produzione
- installare ambienti di test
- eseguire debug nei microservizi

> Una checklist di notifica modifiche serve a:
- misurare il carico computazionale
- limitare l'uso di vincoli nei metodi
- **garantire la tracciabilità delle modifiche** ✅
- aggiornare automaticamente il codice

### Difficoltà 3

> Gli architecture liaisons gestiscono:
- le revisioni dei database di progetto
- le dipendenze tra classi e sottosistemi
- l'integrazione con il sistema operativo
- **le interfacce pubbliche dei propri sottosistemi** ✅

> I contratti nell'object design definiscono:
- le specifiche dell'interfaccia grafica
- **le condizioni per l'invocazione dei metodi** ✅
- il ciclo di vita del software
- i livelli di priorità degli oggetti

> Il design by contract permette di:
- modificare classi in modo anonimo
- evitare l'uso di tool di versionamento
- automatizzare la scrittura della documentazione
- **assicurare il rispetto delle condizioni a runtime** ✅

> Una modifica a un'interfaccia pubblica va:
- applicata senza informare gli altri team
- **documentata e comunicata tempestivamente** ✅
- gestita solo a progetto concluso
- effettuata da un team esterno

### Difficoltà 4

> Il configuration manager assicura:
- **la coerenza tra versioni di codice e documentazione** ✅
- la presenza di commenti nei log di esecuzione
- l'uso del linguaggio UML per tutte le interfacce
- l'approvazione delle specifiche funzionali

> Un beneficio dell'uso dei contratti è:
- la possibilità di integrare interfacce REST
- la verifica della grafica responsive
- **la generazione automatica di test** ✅
- l'accesso diretto alle API di basso livello

---
## Mapping tra modelli e codice

### Difficoltà 2

> Il refactoring consiste in una trasformazione che:
- agisce unicamente sui diagrammi UML
- **non altera il comportamento esterno del sistema** ✅
- aggiunge nuove funzionalità
- modifica la semantica del codice

> Il forward engineering permette di:
- trasformare la base dati in classi
- estrarre i modelli concettuali dal codice
- ristrutturare il codice esistente
- **generare codice a partire da un modello UML** ✅

> Il reverse engineering viene usato quando:
- si vuole cancellare il codice esistente
- si vuole evitare l'uso di diagrammi UML
- si vuole creare una nuova funzionalità
- **il modello è assente o obsoleto** ✅

> Il caching consente di:
- incrementare il numero di classi nel modello
- duplicare ogni accesso alla memoria
- **memorizzare i risultati di operazioni complesse** ✅
- rendere ogni operazione più lenta

> Le associazioni 1:N sono realizzate in codice tramite:
- array multidimensionali
- **collezioni come Set o List** ✅
- file temporanei
- pointer generici

### Difficoltà 4

> Il Proxy Pattern è utile per:
- **ritardare il caricamento di oggetti costosi** ✅
- creare nuove istanze di oggetti
- comprimere i dati associati
- validare modelli UML

> In Java, i contratti vengono simulati tramite:
- **gestione delle eccezioni** ✅
- sovraccarico dei metodi
- ereditarietà multipla
- macro predefinite

> La strategia vertical mapping prevede:
- un'unica classe per tutti i dati
- una tabella unica per tutta la gerarchia
- **una tabella per ogni classe nella gerarchia** ✅
- solo l'uso di chiavi surrogate

> Per mantenere la coerenza tra codice e modello si può usare:
- editing diretto senza vincoli
- debugging al termine del progetto
- naming libero
- **code review con riferimento ai diagrammi** ✅

> Per garantire consistenza nel mapping è utile:
- evitare commenti nel codice
- **usare la stessa nomenclatura tra codice e modello** ✅
- non aggiornare i modelli UML
- scrivere i diagrammi a mano

---
## Introduzione al Testing

### Difficoltà 2

> Il testing del software viene spesso sottovalutato in ambito industriale perché:
- è sempre automatizzato e semplice da gestire
- richiede troppa documentazione
- **è percepito come un costo da minimizzare** ✅
- non contribuisce alla qualità del prodotto

> Il testing ha l'obiettivo principale di:
- **scoprire difetti prima che causino danni** ✅
- evitare l'uso di database relazionali
- documentare le funzionalità principali
- scrivere codice più velocemente

> Nel testing, gli sviluppatori si occupano di:
- gestire le licenze del software
- analizzare il mercato di riferimento
- **scrivere test unitari e supportare la diagnosi dei difetti** ✅
- redigere i contratti con i clienti

> Un beneficio del testing è che:
- elimina la necessità di specifiche tecniche
- aumenta la dimensione del codice sorgente
- diminuisce l'importanza del debugging
- **fornisce un feedback oggettivo sullo stato del sistema** ✅

### Difficoltà 3

> Un software safety-critical è definito tale quando:
- è scritto in un linguaggio di basso livello
- ha un'interfaccia utente molto complessa
- viene eseguito su dispositivi embedded
- **può causare danni a persone o ambienti se malfunzionante** ✅

> La fase di progettazione dei test serve a:
- eseguire il collaudo hardware
- creare diagrammi UML del database
- automatizzare la scrittura del codice
- **definire casi di test e criteri di successo** ✅

> Il testing da solo non basta perché:
- richiede una conoscenza approfondita dei database
- **alcuni difetti emergono solo in condizioni molto specifiche** ✅
- è sempre troppo costoso da implementare
- non copre i casi di uso normale

> Il concetto di shift-left testing promuove:
- l'uso esclusivo di test manuali
- **l'integrazione del testing nelle fasi iniziali** ✅
- la centralizzazione dei test su un server remoto
- l'eliminazione del testing durante lo sviluppo

### Difficoltà 4

> Un errore nel software dello Space Shuttle Columbia nel 1981 fu causato da:
- **una modifica errata avvenuta due anni prima** ✅
- una errata accensione dei propulsori
- una perdita di carburante durante il lancio
- un malfunzionamento dei sensori di bordo

> Un insegnamento chiave dal caso Columbia è che:
- i test devono essere condotti solo in laboratorio
- **anche piccoli cambiamenti possono avere effetti imprevisti** ✅
- gli astronauti devono verificare ogni riga di codice
- i test automatici sono sempre sufficienti

---
## Attività di Testing

### Difficoltà 2

> Il test di unità verifica:
- la grafica dell'interfaccia
- i moduli integrati
- **singole unità di codice in isolamento** ✅
- il comportamento dell'utente

> Il pilot testing consente:
- **uso reale da parte di utenti reali** ✅
- simulazione automatica dei dati
- debugging del codice
- esecuzione di test unitari avanzati

### Difficoltà 3

> L'integration testing serve a:
- testare l'intero sistema in produzione
- controllare il codice sorgente
- **verificare interazioni tra unità** ✅
- valutare prestazioni del sistema

> La strategia top-down nel testing di integrazione parte da:
- componenti di basso livello
- **l'interfaccia utente o API** ✅
- il database
- i moduli centrali

> I test stub simulano:
- moduli di alto livello
- funzioni di sicurezza
- **moduli di basso livello** ✅
- prestazioni del sistema

> La strategia Big Bang integra:
- moduli top-down
- moduli bottom-up
- **tutti i componenti contemporaneamente** ✅
- solo l'interfaccia grafica

> Il testing di sistema include:
- solo test funzionali
- verifiche hardware
- **test funzionali e non funzionali** ✅
- documentazione di progetto

> Il testing non funzionale si concentra su:
- l'interazione tra moduli
- **aspetti come performance e sicurezza** ✅
- la correttezza dei dati
- le funzionalità mancanti

> Il performance testing valuta:
- la correttezza delle formule
- **i tempi di risposta sotto carico** ✅
- la compatibilità con i dispositivi
- le scorciatoie da tastiera

### Difficoltà 5

> Uno shadow test confronta:
- due versioni grafiche
- **vecchio e nuovo sistema in parallelo** ✅
- due framework di test
- gli ambienti di sviluppo

---
## Gestione del processo di testing

### Difficoltà 2

> Cosa definisce principalmente il Test Plan:
- **la strategia generale del testing** ✅
- il piano di sviluppo hardware
- l'aspetto visivo dell'interfaccia utente
- la strategia di marketing del software

> A cosa serve il Test Case Specification:
- a gestire le modifiche di progetto
- a validare le decisioni del cliente
- **a descrivere nel dettaglio ogni singolo test** ✅
- a correggere i bug nel codice

> Qual è lo scopo del Test Summary Report:
- **riassumere i risultati dei test eseguiti** ✅
- definire nuove feature
- descrivere i limiti hardware
- delineare i contenuti grafici

> A cosa servono i test di regressione:
- a ridurre i costi del team di marketing
- a progettare nuovi moduli grafici
- a creare nuove specifiche utente
- **a verificare che modifiche non compromettano funzionalità esistenti** ✅

> Quando è consigliabile eseguire test di regressione:
- **dopo ogni aggiornamento o bug fix** ✅
- solo durante il rilascio iniziale
- prima della progettazione
- dopo il test dell'interfaccia grafica

> Perché è utile automatizzare i test di regressione:
- per evitare la scrittura di codice
- per generare nuove funzionalità
- per creare documenti di progetto
- **per garantire ripetibilità e velocità di esecuzione** ✅

### Difficoltà 3

> Cosa deve specificare il Test Plan riguardo alle funzionalità da testare:
- tutte le funzionalità visibili all'utente
- **quali verranno testate e quali escluse, con motivazione** ✅
- solo le parti in via di sviluppo
- le funzionalità usate dal team di sviluppo

> Quando un test si considera superato secondo il Test Plan:
- quando l'utente finale è soddisfatto
- quando viene eseguito senza errori di sintassi
- **quando l'output effettivo coincide con quello atteso** ✅
- quando il team di sviluppo lo approva

> Cosa contiene un Test Incident Report:
- la descrizione dell'interfaccia grafica
- la lista dei test pianificati
- le specifiche dei moduli non testati
- **la documentazione di anomalie riscontrate** ✅

> In cosa consiste la tecnica di test case prioritization:
- rimuovere tutti i test obsoleti
- eseguire i test più semplici prima
- **ordinare i test per criticità e valore** ✅
- creare nuovi requisiti

---
## Tecniche per la selezione dei casi di test

### Difficoltà 2

> Il random testing:
- richiede la conoscenza del codice sorgente
- è sempre più efficace del test sistematico
- **non garantisce copertura mirata** ✅
- è adatto solo per test funzionali

> Il black-box testing:
- **è indipendente dall'implementazione del codice** ✅
- consente la verifica dei percorsi interni del codice
- richiede l'analisi delle strutture di controllo
- è utile solo per i test unitari

> Le classi di equivalenza:
- si applicano solo a campi numerici
- non sono rilevanti per il comportamento del sistema
- devono essere testate tutte con lo stesso input
- **coprono sia input corretti che errati** ✅

> Il Weak Equivalence Class Testing:
- **è utile per test preliminari con input indipendenti** ✅
- richiede la verifica di tutte le combinazioni possibili
- è adatto solo a sistemi ad alta criticità
- si usa nei test di performance

### Difficoltà 3

> Il test esaustivo:
- è applicabile solo in ambienti regolamentati
- **richiede di testare tutte le combinazioni possibili** ✅
- è consigliato per ogni fase di sviluppo
- produce risultati affidabili in tempi brevi

> Il test sistematico:
- si affida esclusivamente all'intuizione del tester
- non è adatto a progetti a lungo termine
- produce risultati non tracciabili
- **permette una copertura elevata delle condizioni critiche** ✅

> Il white-box testing:
- non richiede accesso al codice sorgente
- **permette l'identificazione di codice morto** ✅
- si limita a verificare gli output del sistema
- è adatto solo per applicazioni semplici

> L'Equivalence Class Testing:
- aumenta la ridondanza dei test
- richiede la verifica di ogni singolo input
- **riduce il numero di test mantenendo la copertura** ✅
- ignora completamente i valori anomali

> Le tecniche di testing sistematico:
- escludono la necessità di automazione
- si applicano solo ai test esplorativi
- trascurano la documentazione dei test
- **ottimizzano il rapporto tra costi e benefici** ✅

### Difficoltà 4

> Lo Strong Equivalence Class Testing:
- ignora completamente le dipendenze tra input
- **aumenta la copertura funzionale combinando parametri** ✅
- non considera le classi non valide
- è limitato ai test di interfaccia

---
## Testing White Box

### Difficoltà 2

> Il testing white box è particolarmente utile per individuare:
- errori nei requisiti funzionali
- **errori logici e strutturali** ✅
- bug segnalati dagli utenti
- problemi nell'interfaccia utente

> La branch coverage verifica che siano esercitati:
- le variabili globali
- le funzioni principali
- **entrambi i rami delle decisioni** ✅
- solo le istruzioni principali

### Difficoltà 3

> Il testing white box:
- ignora i cicli logici
- non richiede accesso al codice
- si basa solo sull'output del programma
- **richiede conoscenza del codice** ✅

> La condition coverage richiede che ogni condizione sia valutata:
- **sia vera che falsa** ✅
- in base ai parametri di input
- senza condizioni logiche
- solo quando vera

> Una delle principali sfide della generazione automatica è la:
- facilità d'uso
- **mancanza di oracolo di test** ✅
- scarsità di strumenti
- velocità di calcolo

### Difficoltà 4

> Il white box testing richiede come prerequisito:
- test funzionali
- esperienza utente
- simulazione grafica
- **accesso al codice sorgente** ✅

> La statement coverage verifica che ogni istruzione sia eseguita:
- in ordine alfabetico
- solo se condizionale
- **almeno una volta** ✅
- almeno due volte

> La path coverage mira a verificare:
- le condizioni sempre vere
- **ogni possibile percorso esecutivo** ✅
- solo le decisioni principali
- le variabili locali

> Il mutation testing valuta la qualità della suite di test attraverso:
- test dell'interfaccia
- **mutanti introdotti nel codice** ✅
- copertura funzionale
- debugging manuale

> Un vantaggio della generazione automatica è la sua capacità di:
- ignorare condizioni complesse
- evitare la manutenzione
- **coprire percorsi difficilmente intuibili** ✅
- testare solo l'interfaccia

---
## Test-Driven-Development

### Difficoltà 2

> Nel ciclo Red-Green-Refactor:
- si scrive il codice e poi si scrive un test
- **si scrive un test che fallisce, si scrive codice minimo per superarlo, poi si rifattorizza** ✅
- si implementa tutto il codice e infine si testano tutte le funzionalità
- si verifica che il codice sia compilabile prima di scrivere il test

> Le tre leggi del TDD aiutano a:
- automatizzare le interfacce grafiche
- rimuovere ogni tipo di errore
- **evitare lo sviluppo eccessivo e mantenere il codice semplice** ✅
- scrivere test più lunghi

> Il TDD guida lo sviluppatore a:
- scrivere documentazione tecnica tradizionale
- utilizzare strumenti complessi
- **pensare al comportamento del codice prima dell'implementazione** ✅
- concentrarsi sulle performance

### Difficoltà 3

> Uno dei vantaggi principali del TDD è:
- **l'incremento della qualità grazie al feedback immediato** ✅
- la totale eliminazione dei bug
- la riduzione del numero di funzionalità
- l'aumento della velocità di sviluppo

> Scrivere test prima del codice aiuta a:
- gestire le risorse di sistema
- **produrre codice orientato agli utenti** ✅
- limitare la scrittura di documentazione
- automatizzare l'installazione

> Il refactoring dei test prevede:
- scrivere codice non testato
- **migliorare la leggibilità mantenendo il test valido** ✅
- aggiungere test multipli per coprire tutto
- rimuovere la struttura del test

> Il TDD migliora la qualità del codice perché:
- si usa un compilatore più potente
- si usano linguaggi funzionali
- **ogni modifica è validata da test automatizzati** ✅
- tutti gli sviluppatori scrivono codice simile

### Difficoltà 4

> Il principio F.I.R.S.T. suggerisce che un buon test deve essere:
- **fast, independent, repeatable, self-validating, thorough** ✅
- frequent, integrated, realistic, secure, testable
- focused, instant, redundant, silent, targeted
- fixed, isolated, reliable, strong, traceable

> I test smell sono:
- pattern di codice consigliati
- strumenti per migliorare i test
- **indicazioni di potenziali problemi nei test** ✅
- errori di sintassi nei test automatici

> Metriche qualitative sul TDD valutano:
- la quantità di documentazione
- **la leggibilità e robustezza dei test** ✅
- il numero di sviluppatori
- la velocità di esecuzione

---
## Introduzione a Software Project Management

### Difficoltà 2

> Quale tra le seguenti affermazioni descrive correttamente il ruolo del project manager:
- **guida il processo organizzativo coordinando team e stakeholder** ✅
- scrive direttamente codice e documentazione
- analizza solo i requisiti e li comunica ai clienti
- si occupa esclusivamente della fase di testing

> Una caratteristica del modello WBS è che:
- **organizza il lavoro in una gerarchia di task e attività** ✅
- mostra la sequenza temporale dei task
- definisce le competenze necessarie per ogni attività
- consente la verifica automatica dei deliverable

> La skill matrix viene utilizzata per:
- misurare l'efficienza del codice prodotto
- definire le milestone del progetto
- determinare le metriche di qualità del prodotto
- **mappare competenze, conoscenze e interessi dei membri del team** ✅

> Il documento SPMP ha come obiettivo primario:
- **guidare l'esecuzione del progetto e garantire comunicazione tra le parti** ✅
- testare il prodotto finito con gli utenti finali
- definire le tecniche di programmazione da adottare
- realizzare i diagrammi UML e distribuirli

> Un deliverable si definisce come:
- un documento per la validazione formale
- un'attività interna del team di sviluppo
- un vincolo temporale specificato dallo sponsor
- **un prodotto destinato al cliente come risultato finale** ✅

### Difficoltà 3

> Il postmortem in un progetto software consiste in:
- condurre interviste con i clienti per raccogliere nuovi requisiti
- verificare l'aderenza del codice agli standard IEEE
- testare il software in condizioni di carico massimo
- **analizzare a posteriori il progetto per migliorare i processi futuri** ✅

> Nel contesto SWEBOK, l'area Software Quality riguarda:
- l'installazione del sistema software finale
- la raccolta dei requisiti funzionali
- la progettazione dell'architettura di sistema
- **la definizione di metriche e verifica della conformità agli standard** ✅

> Il project manager nella fase di Steady State gestisce principalmente:
- la definizione iniziale degli obiettivi
- la chiusura contrattuale e la migrazione dati
- **il rischio, la comunicazione continua e il replanning** ✅
- il setup dell'infrastruttura e la skill matrix

> Un work package contiene:
- il manuale utente e i piani di test
- **una descrizione dettagliata di task, risorse e output** ✅
- l'elenco dei vincoli contrattuali del progetto
- la valutazione dei rischi futuri

> Il SPMP è un documento che:
- contiene esclusivamente informazioni sulle risorse hardware
- descrive la struttura del codice implementato
- **guida e documenta l'intera gestione del progetto software** ✅
- sintetizza i risultati del collaudo finale

---
## Risk Management

### Difficoltà 1

> Il brainstorming è una tecnica utile per:
- risolvere automaticamente i rischi già identificati
- **generare idee sui rischi in modo creativo e collaborativo** ✅
- escludere i membri junior dal processo decisionale
- creare checklist di controllo dei rischi

### Difficoltà 2

> Nel contesto dei progetti software, il rischio rappresenta:
- un problema già accaduto che richiede una soluzione immediata
- una decisione errata presa nella fase di progettazione
- **un evento incerto che può compromettere il buon esito del progetto** ✅
- un errore di calcolo nei tempi di consegna

> L'approccio proattivo nella gestione dei rischi consiste in:
- **pianificare azioni per ridurre la probabilità o l'impatto dei rischi** ✅
- intervenire solo dopo che il rischio si è manifestato
- affidarsi all'esperienza del team per risolvere i problemi
- delegare la gestione dei rischi a fornitori esterni

> Il risk register viene utilizzato per:
- **registrare e aggiornare tutte le informazioni sui rischi individuati** ✅
- definire gli obiettivi tecnici del progetto
- gestire le comunicazioni tra team e stakeholder
- documentare i test effettuati durante lo sviluppo

> Il monitoraggio dei rischi serve a:
- aggiornare i task di sviluppo quotidianamente
- controllare la produttività del team tecnico
- validare i documenti di progetto prima del rilascio
- **verificare l'efficacia delle contromisure e individuare nuovi rischi** ✅

### Difficoltà 3

> La gestione dei rischi deve essere attuata:
- solo durante la fase di pianificazione iniziale
- quando si verificano problemi gravi
- **in tutte le fasi del progetto con aggiornamenti continui** ✅
- una sola volta all'inizio del progetto

> I rischi di natura tecnica comprendono:
- conflitti tra gli stakeholder e il team
- ritardi dovuti a vincoli legali e normativi
- scarsa motivazione del personale
- **errori di progettazione o difficoltà di integrazione tra moduli** ✅

> Una strategia di evitamento del rischio prevede di:
- accettare il rischio senza intraprendere azioni specifiche
- trasferire il rischio a un partner esterno
- ridurre la probabilità tramite azioni preventive
- **modificare il piano per eliminare la causa del rischio** ✅

> Una strategia di trasferimento del rischio comporta:
- affrontare il rischio internamente tramite un owner dedicato
- ignorare il rischio fino alla sua manifestazione
- **delegare il rischio tramite accordi o assicurazioni** ✅
- eliminare tutte le fonti di rischio note

### Difficoltà 4

> La matrice di rischio viene utilizzata per:
- registrare i costi di sviluppo
- **visualizzare graficamente la combinazione tra probabilità e impatto** ✅
- monitorare i tempi di consegna
- validare i requisiti funzionali

---
## Quality Management

### Difficoltà 2

> La gestione della qualità software si articola in tre livelli operativi:
- **organizzativo, di progetto e pianificazione** ✅
- modularità, coesione e accoppiamento
- codice, documentazione e testing
- analisi, progettazione e deploy

> Gli standard di prodotto definiscono caratteristiche degli artefatti software:
- **come formato dei documenti e stile del codice** ✅
- come struttura hardware necessaria
- come velocità di esecuzione
- come budget e deadline

> Gli standard di processo riguardano le modalità di sviluppo:
- **come workflow e procedure di rilascio** ✅
- come il design grafico delle interfacce
- come l'uso di specifici linguaggi
- come la lunghezza del codice

> Le revisioni del codice sono attività di verifica statica:
- **che non richiedono esecuzione** ✅
- eseguite dopo il testing
- basate sulla simulazione del software
- limitate ai documenti di progetto

> Nel pair programming la revisione avviene in tempo reale:
- grazie all'uso di checklist automatiche
- **tramite sviluppo simultaneo da parte di due sviluppatori** ✅
- tramite strumenti di compilazione condivisa
- tramite ispezione post-deploy

> Le metriche di controllo sono legate ai processi di sviluppo:
- come la profondità dell'ereditarietà
- come la leggibilità del codice
- **come l'effort medio per task** ✅
- come il numero di bug in produzione

### Difficoltà 3

> La qualità del processo può influenzare la qualità del prodotto:
- **ma non garantisce automaticamente un buon prodotto** ✅
- garantendo sempre un risultato perfetto
- solo nei progetti a lungo termine
- solo in ambito industriale

> La norma ISO 9001 fornisce un sistema di gestione della qualità:
- **applicabile anche allo sviluppo software** ✅
- esclusivo per il software
- che certifica direttamente il codice
- utilizzabile solo da grandi aziende

> Il moderatore nelle revisioni:
- si occupa del debugging
- sostituisce l'autore del codice
- **garantisce ordine e produttività** ✅
- scrive il codice esaminato

> Le metriche software aiutano a prendere decisioni informate:
- solo nei progetti hardware
- esclusivamente per il refactoring
- solo nel testing manuale
- **trasformando dati soggettivi in valori oggettivi** ✅

---
## Introduzione a Rationale Management

### Difficoltà 3

> L'assenza di rationale nelle decisioni rende:
- più semplice la revisione del software
- **difficile la comprensione futura delle scelte** ✅
- più comprensibile il codice
- immediata la manutenzione

> Il rationale strutturato include:
- solo la scelta finale
- una lista di attività
- le regole di programmazione
- **le alternative, i vincoli e le motivazioni** ✅

> Un esempio di informazione documentata nel rationale è:
- il nome dello sviluppatore
- la versione del compilatore
- il tempo impiegato per una riunione
- **la motivazione per una scelta architetturale** ✅

> Una modalità informale di documentazione del rationale è:
- modelli QOC
- **commenti nel codice** ✅
- diagrammi UML
- grafici IBIS

> Tra i limiti del Rationale Management c'è:
- la mancanza di strumenti informatici
- la difficoltà di traduzione
- **l'obsolescenza della documentazione** ✅
- l'impossibilità di aggiornare il codice

> Il rationale ben strutturato è utile per:
- **audit e certificazioni** ✅
- riscrivere il codice da zero
- sostituire i processi agili
- aggirare le normative

> Il rationale dovrebbe essere:
- statico e centralizzato
- generato alla fine del progetto
- **mantenuto aggiornato nel tempo** ✅
- legato solo al codice

> Un issue nel modello IBIS rappresenta:
- una libreria software
- **un problema o domanda** ✅
- una decisione finale
- una revisione del codice

> Nel modello QOC, i Criteria servono a:
- **valutare le alternative** ✅
- generare automaticamente codice
- testare le opzioni
- decidere il nome del progetto

> Il DRL è utile in contesti:
- rapidi e agili
- non regolamentati
- privati
- **ad alta criticità** ✅

---
## Rationale Management: dai Problemi alle Decisioni

### Difficoltà 1

> La cattura asincrona del rationale avviene tramite:
- **strumenti collaborativi come wiki o issue tracker** ✅
- sistemi di build automatica
- documentazione cartacea
- log dei server

> Il rationale migliora l'onboarding dei nuovi sviluppatori:
- perché mostra i bug corretti
- **perché rende comprensibili le scelte progettuali** ✅
- perché include diagrammi UML
- perché automatizza il setup del progetto

### Difficoltà 2

> Il rationale editor ha il compito di:
- **gestire e aggiornare il repository del rationale** ✅
- scrivere le specifiche funzionali
- tradurre i requisiti in codice
- eseguire i test di sistema

> Il minute taker registra le decisioni in tempo reale:
- **durante i meeting del progetto** ✅
- durante la fase di test
- durante la scrittura della documentazione
- durante l'analisi dei requisiti

> Una strategia per migliorare la comunicazione del rationale è:
- evitare la verbalizzazione delle decisioni
- utilizzare solo documenti cartacei
- limitare la documentazione ai manager
- **centralizzare le informazioni in un repository condiviso** ✅

> Il modello WinWin aiuta a:
- progettare interfacce grafiche
- documentare i test automatici
- scrivere codice più efficiente
- **raggiungere decisioni condivise tra stakeholder** ✅

### Difficoltà 3

> Gestire il rationale riduce i costi delle modifiche tardive:
- perché evita la documentazione
- perché obbliga alla riscrittura del codice
- **perché consente di valutare le scelte pregresse** ✅
- perché elimina i test

> La revisione del rationale serve a:
- sostituire i modelli UML
- scrivere nuovi requisiti funzionali
- **aggiornare le decisioni alla luce di nuove esigenze** ✅
- automatizzare i test di regressione

> La negoziazione nel software è anche un processo sociale:
- perché si basa esclusivamente su dati
- **perché coinvolge stakeholder con interessi diversi** ✅
- perché avviene dopo lo sviluppo
- perché non richiede documentazione

### Difficoltà 4

> Quando il consenso non è raggiunto, si può ricorrere a:
- abbandonare la documentazione
- eliminare le opzioni disponibili
- sospendere lo sviluppo
- **strategie strutturate come il voto o l'intervento del management** ✅

---
## Configuration Management

### Difficoltà 2

> Il Configuration Management:
- **rende visibili e tracciabili i cambiamenti** ✅
- impedisce ogni forma di aggiornamento
- sostituisce gli sviluppatori nei processi decisionali
- elimina completamente il rischio di bug

> Il Configuration Management interviene:
- esclusivamente nella fase di design
- **dall'analisi alla manutenzione** ✅
- dal test fino al rilascio finale
- solo durante la manutenzione

> Un Configuration Item:
- riguarda solo i dati utente
- non viene mai versionato
- **può essere un documento tecnico** ✅
- è sempre un file eseguibile

> Il Configuration Management favorisce la collaborazione tra i team:
- bloccando le modifiche concorrenti
- **attraverso una gestione coordinata delle versioni** ✅
- evitando il versionamento condiviso
- introducendo confusione nelle versioni

> Il Configuration Manager
- esegue test funzionali
- **implementa il processo e definisce i Configuration Items** ✅
- approva le modifiche in autonomia
- scrive il codice sorgente

### Difficoltà 3

> Le baseline:
- vengono sempre rifiutate
- sono modificabili da tutti gli utenti
- non richiedono approvazioni formali
- **costituiscono punti di partenza stabili** ✅

> Le promotions:
- **devono essere compilabili e testabili** ✅
- sono sempre definitive
- possono essere modificate liberamente
- sono distribuite solo ai clienti

> Il Software Configuration Management Plan:
- non viene mai aggiornato
- è mantenuto da sviluppatori junior
- **stabilisce modalità operative del CM** ✅
- è gestito da sistemi automatici esterni

> Una change request formale:
- impedisce la validazione
- non viene mai documentata
- elimina la tracciabilità
- **include impatti e soluzione proposta** ✅

### Difficoltà 4

> La gestione delle varianti:
- si applica solo ai sistemi embedded
- **prevede riuso e adattamenti mirati** ✅
- elimina ogni dipendenza tra componenti
- impedisce ogni modifica al codice

---
## People Management

### Difficoltà 2

> Il People Management nei progetti software consente di migliorare:
- la velocità del compilatore
- la complessità dell'algoritmo
- la lunghezza del codice
- **la coesione del team** ✅

> Un buon manager tecnico deve possedere competenze:
- di compilazione
- esclusivamente tecniche
- **tecniche, relazionali e organizzative** ✅
- solo manageriali

> Il ruolo del QA Engineer è quello di:
- scrivere documentazione
- sviluppare codice
- **testare e garantire qualità** ✅
- definire le priorità funzionali

> Un onboarding efficace consente di:
- aumentare la complessità iniziale
- generare stress
- **favorire l'integrazione e la produttività** ✅
- allungare i tempi di progetto

> Il mentoring si basa su una relazione tra:
- pari con pari
- manager e cliente
- **senior e junior** ✅
- coach e manager

> Un buon clima relazionale nel team favorisce:
- **l'aumento della produttività** ✅
- i silos informativi
- la competitività interna
- le tensioni

### Difficoltà 3

> Secondo Daniel Pink, tra i principali fattori motivanti troviamo:
- benefit economici
- **autonomia, competenza e scopo** ✅
- stabilità e routine
- compiti semplici e ripetitivi

> La gestione della diversità aumenta:
- **la creatività e l'inclusività** ✅
- la rigidità del team
- le disuguaglianze
- il turnover aziendale

> Il lavoro remoto richiede particolare attenzione a:
- installazione hardware
- connessioni VPN
- **coesione e comunicazione** ✅
- tempi di deploy

> Nel People Management Agile, il manager assume il ruolo di:
- controllore gerarchico
- osservatore esterno
- valutatore solitario
- **facilitatore di team** ✅

---
## Strumenti di collaborazione

### Difficoltà 2

> La Continuous Integration prevede:
- gestione delle dipendenze di rete
- utilizzo di strumenti di backup
- **integrazione frequente del codice nel repository** ✅
- modifiche periodiche ai flussi di lavoro

### Difficoltà 3

> La To-Do List è particolarmente adatta per:
- **attività individuali o piccoli team** ✅
- coordinamento asincrono
- gestione iterativa dei task
- progetti complessi e distribuiti

> Il metodo Kanban si basa su:
- gestione sprint
- strutture gerarchiche
- **visualizzazione del flusso di lavoro** ✅
- task predefiniti a lungo termine

> Nel metodo Scrum gli sprint servono a:
- gestire la manutenzione del codice
- **lavorare su funzionalità prioritarie** ✅
- tracciare le modifiche
- scrivere report periodici

> Un ruolo fondamentale nello Scrum è:
- **lo scrum master** ✅
- il tecnico DevOps
- il release engineer
- il program manager

> Git è definito come un sistema:
- per la gestione delle risorse umane
- di test automatizzati
- **distribuito di controllo delle versioni** ✅
- di monitoraggio delle performance

> Un commit in Git rappresenta:
- una segnalazione di errore
- **una registrazione delle modifiche** ✅
- una copia del repository
- una nuova funzionalità da pianificare

> Le pull request in GitHub servono a:
- iniziare un nuovo progetto
- creare branch secondari
- testare le performance del sistema
- **rivedere e approvare modifiche** ✅

> Le code review servono a:
- **consolidare le competenze e migliorare la qualità** ✅
- sostituire il team leader
- aumentare la complessità del codice
- eliminare il lavoro di gruppo

### Difficoltà 4

> Il branch in Git consente di::
- gestire attività amministrative
- **lavorare su nuove funzionalità senza influenzare il main** ✅
- modificare il sistema operativo
- esportare il codice

---
## Strutture di collaborazione e cenni su community smells

### Difficoltà 2

> La community nei contesti moderni si distingue perché:
- è sempre localizzata nello stesso luogo
- ha ruoli fissi e gerarchie rigide
- **è spesso auto-organizzata e fluida** ✅
- non richiede strumenti digitali

> La diversità in una community può favorire:
- la riduzione della motivazione
- la creazione di conflitti non risolvibili
- la centralizzazione delle decisioni
- **l'innovazione e la qualità delle soluzioni** ✅

> I Formal Groups si caratterizzano per:
- **ruoli chiari e responsabilità definite** ✅
- strutture completamente informali
- mancanza di leadership
- assenza di controllo delle attività

### Difficoltà 3

> La socio-technical congruence rappresenta:
- la quantità di codice prodotto
- il numero di strumenti digitali usati
- la distanza tra membri del team
- **l'allineamento tra struttura tecnica e sociale** ✅

> Il social debt può derivare da:
- **assenza di feedback e documentazione** ✅
- uso eccessivo di strumenti digitali
- presenza di mentoring formale
- partecipazione costante alle retrospettive

> Le Community of Practice sono costituite da membri che:
- **condividono interessi e pratiche comuni** ✅
- ignorano la formazione continua
- seguono solo ruoli gerarchici formali
- rifiutano l'apprendimento collettivo

> Il community smell 'Lone Wolf' indica:
- **mancanza di collaborazione da parte di un membro** ✅
- partecipazione eccessiva a tutte le attività
- condivisione proattiva delle decisioni
- presenza diffusa di mentoring

> Il 'Bottleneck' si verifica quando:
- tutti i membri hanno uguale visibilità
- la comunicazione è distribuita equamente
- non esistono ruoli di leadership
- **una persona è centrale in modo eccessivo nei processi** ✅

> Il 'Black Cloud' si manifesta attraverso:
- distribuzione equa del lavoro
- **sovraccarico informativo e canali ridondanti** ✅
- feedback costante e strutturato
- chiarezza nei processi decisionali

### Difficoltà 4

> Il smell 'Organizational Silo' comporta:
- **frammentazione tra sottogruppi che non comunicano** ✅
- documentazione centralizzata
- alta visibilità tra i collaboratori
- coordinamento continuo tra team

---
## Storia, principi e sintassi del linguaggio Java

### Difficoltà 1

> Quali fra le seguenti dichiarazioni di classe in Java è corretta:
- public class {...}
- public Class Auto {...}
- **public class Auto {...}** ✅
- nessuna è corretta

> In Java il blocco di codice che definisce un metodo è delimitato da:
- **parentesi graffe** ✅
- parentesi tonde
- parentesi quadre
- nessun elemento delimitatore

### Difficoltà 2

> Quali fra le seguenti affermazioni sul metodo main in Java è scorretta:
- deve essere definito in ogni applicazione Java
- **deve essere sempre definito in ciascuna classe del programma** ✅
- deve essere sempre definito in una classe definita per il programma
- rappresenta il punto di partenza dell'esecuzione di ogni programma

> In Java è possibile dichiarare un metodo al di fuori del blocco di codice che definisce una classe:
- sì, sempre
- **no, mai** ✅
- dipende dal metodo
- dipende dalla classe

> Quale delle seguenti affermazioni sul linguaggio Java è falsa:
- è un linguaggio orientato agli oggetti
- permette di svincolarsi dalla piattaforma
- ha una sintassi simile a C/C++
- **funziona anche senza Java Virtual Machine** ✅

> In programmazione orientata agli oggetti, cosa rappresenta l'invio di un messaggio a un oggetto
- l'accesso diretto ai suoi attributi interni
- la modifica automatica della sua classe
- **l'invocazione di un metodo definito nell'oggetto** ✅
- l'inizializzazione dell'oggetto tramite costruttore

### Difficoltà 3

> In object-oriented, un attributo di un oggetto è:
- **una proprietà statica che intrinsiamente distingue l'oggetto da tutti gli altri della stessa classe** ✅
- una proprietà statica di un gruppo di oggetti di classi diverse
- una proprietà dinamica che dipende dal contesto in cui l'oggetto è istanziato
- una proprietà statica dell'oggetto il cui valore è fisso

> In object-oriented un'operazione in un oggetto indica:
- è un'azione che un oggetto esegue in modo alternativo ad altri oggetti
- **è un'azione che un oggetto esegue su invocazione di un suo metodo** ✅
- è un'azione eseguita in modo diverso a seconda dell'istanza
- è un'azione che è definita ma non viene mai eseguita

> In object-oriented incapsulamento isignfica:
- **accesso ai dati regolato da apposita interfaccia** ✅
- trascurare elementi non essenziali nella modellazione di un oggetto
- accesso diretto e libero a tutti i dati dell'oggetto
- accesso negato a tutti a ciascun dato dell'oggetto

> In object-oriented, astrazione signfica:
- a mettere insieme dati ed operazioni nella modellazione di un concetto tramite oggetto
- trascurare le operazioni che l'oggetto può svolgere nella fase di modellazione dello stesso
- **trascurare elementi non essenziali nella modellazione di un concetto per la risoluzione di un problema** ✅
- riportare ogni dettaglio nella modellazione di un concetto per la risoluzione di un concetto

---
## Tipi primitivi, selezione e iterazione

### Difficoltà 1

> In Java un identificatore può iniziare per @:
- **no, mai** ✅
- sì, nessun problema
- no, ma per gli attributi nessun problema
- sì, solo per le classi

> In Java gli identificatori:
- hanno un limite massimo di caratteri
- **non hanno un limite massimo di caratteri** ✅
- è meglio che siano più slegati il più possibile dai dettagli dei concetti del mondo reale che rappresentano
- più corti sono meglio è

> Secondo le convenzioni di Java gli identficatori della classe:
- devono iniziare per @
- devono iniziare con un numero
- devono iniziare per lettera minuscola
- **devono iniziare per lettera maiuscola** ✅

> Secondo le convenzioni di Java gli identficatori delle variabili:
- devono finire sempre con _
- devono iniziare con un numero
- **devono iniziare per lettera minuscola** ✅
- devono iniziare per lettera maiuscola

> Secondo le convenzioni di Java gli identficatori delle costanti:
- **devono avere tutte lettere maiuscole** ✅
- devono iniziare con un numero
- devono avere tutte lettere minuscole
- devono finire sempre con _

> Secondo le convenzioni di Java gli identficatori dei metodi:
- **devono iniziare per lettera minuscola** ✅
- non deve contenere verbi
- devono iniziare per lettera maiuscola
- devono avere tutte lettere maiuscole

### Difficoltà 2

> In Java, un tipo di dato intero long è memorizzato in:
- **8 byte** ✅
- 6 byte
- 4 byte
- 16 byte

> Il costrutto switch può in ogni caso sostituire il costrutti while:
- **falso, non può mai sostituirlo: la switch è una condizione non un ciclo** ✅
- falso, lo switch è un ciclo non una condizione
- sì, è vero lo può sostituire sempre
- dipende da quanti casi di confronto sono da considerare

### Difficoltà 3

> In Java, il costrutto switch può sostituire in ogni caso il costrutto if:
- sì, è vero lo può sostituire sempre
- falso, solo in caso di if annidati e con test su variabili booleane
- **falso, solo in caso di if concatenati e con test su alcuni tipi di variabili (es. interi)** ✅
- dipende da quanti casi di confronto sono da considerare

> In Java, il costrutto for può in ogni caso sostituire il costrutto while:
- falso, solo in caso di while annidati
- sì, è vero lo può sostituire sempre
- **dipende dalla condizione del ciclo while** ✅
- falso, non lo può mai sostituire

---
## JDK e JRE: compilare ed eseguire programmi in Java

### Difficoltà 1

> Il linguaggio Java è definito come:
- un linguaggio esclusivamente interpretato
- un linguaggio esclusivamente compilato
- un linguaggio procedurale
- **un linguaggio compilato e interpretato** ✅

> Il JRE serve per:
- compilare i programmi Java
- sviluppare librerie Java
- debuggare i programmi Java
- **eseguire i programmi Java** ✅

> La JVM è:
- il compilatore Java
- una libreria Java per la rete
- **la macchina virtuale che esegue il bytecode** ✅
- un'estensione del JRE

> Per eseguire un programma Java compilato occorre almeno:
- **il JRE installato** ✅
- un editor Java
- il JDK installato
- una libreria esterna

### Difficoltà 2

> Il JDK comprende:
- solo l'interprete Java
- solo il debugger
- **il compilatore e altri strumenti per lo sviluppo** ✅
- solo il runtime environment

> Il bytecode è:
- il codice sorgente Java
- il codice eseguibile nativo della macchina
- il codice macchina in C++
- **il codice prodotto dal compilatore Java** ✅

> Il comando javac serve per:
- eseguire un file .java direttamente
- debuggare un'applicazione Java
- verificare la sintassi di un file .java
- **compilare un file .java in bytecode** ✅

> Il comando java serve per:
- creare un file JAR
- compilare un file Java
- **eseguire un file compilato in bytecode** ✅
- editare un file .java

> Il ciclo di sviluppo tipico in Java prevede:
- scrittura, interpretazione, compilazione
- esecuzione, scrittura, debugging
- **scrittura, compilazione, esecuzione** ✅
- compilazione, esecuzione, scrittura

### Difficoltà 3

> Quale tra questi componenti NON è incluso nel JDK?:
- javac
- javap
- **l'interprete Python** ✅
- javadoc

---
## Classi, oggetti, ereditarietà

### Difficoltà 1

> In Java, cosa rappresenta una classe:
- un'istanza di un oggetto
- un tipo di dato primitivo
- **un modello per creare oggetti** ✅
- una libreria esterna

> Cosa permette l'ereditarietà in Java:
- creare oggetti senza classi
- **estendere funzionalità di una classe esistente** ✅
- eseguire codice in parallelo
- condividere variabili globali

> Quale parola chiave si usa per indicare che una classe estende un'altra:
- implement
- **extends** ✅
- inherits
- super

> Come si chiama la classe da cui una sottoclasse eredita:
- subclasse
- **superclass** ✅
- parentclass
- baseclass

> Cosa rappresenta un oggetto in Java:
- un tipo di dato primitivo
- una variabile globale
- **un'istanza di una classe** ✅
- un metodo statico

> Quale tra questi non è un modificatore di accesso in Java:
- public
- private
- protected
- **internal** ✅

### Difficoltà 2

> Qual è la visibilità predefinita dei membri di una classe in Java:
- public
- private
- protected
- **package-private** ✅

> Cosa significa il modificatore 'protected' in Java:
- accessibile solo all'interno della stessa classe
- accessibile da qualsiasi classe
- **accessibile dalle classi dello stesso package e dalle sottoclassi** ✅
- accessibile solo dalle sottoclassi

> Quale tra questi è un vantaggio dell'ereditarietà:
- aumento della complessità del codice
- riduzione del riutilizzo del codice
- **facilitazione della manutenzione del codice** ✅
- difficoltà nella comprensione del codice

> Cosa accade se una sottoclasse ridefinisce un metodo della superclasse:
- si verifica un errore di compilazione
- il metodo della superclasse viene ignorato
- entrambi i metodi vengono eseguiti
- **il metodo della sottoclasse viene eseguito al posto di quello della superclasse** ✅

---
## Polimorfismo, interfacce e classi astratte

### Difficoltà 2

> Una classe astratta in Java:
- può essere instanziata direttamente
- non può contenere metodi astratti
- **può contenere sia metodi astratti che concreti** ✅
- è identica a un'interfaccia

> Un'interfaccia in Java:
- può avere variabili di istanza non statiche
- non può avere metodi con corpo
- **può estendere più interfacce** ✅
- può estendere una sola interfaccia

> Le classi astratte sono utili per:
- testare il codice
- **fornire una base comune per sottoclassi** ✅
- evitare il polimorfismo
- definire solo metodi statici

> Le eccezioni in Java sono:
- sempre ignorate se non gestite
- **oggetti che derivano dalla classe Throwable** ✅
- gestite solo tramite try-catch
- usate solo per errori di sintassi

> Il meccanismo di gestione delle eccezioni serve a:
- creare nuovi thread
- semplificare l'ereditarietà
- interrompere il programma in caso di errore
- **gestire situazioni anomale in modo controllato** ✅

### Difficoltà 3

> Il polimorfismo consente di:
- definire una classe senza implementarla
- **eseguire un metodo specifico a runtime a seconda dell'istanza** ✅
- creare istanze di classi astratte
- ereditare metodi statici

> Il vantaggio principale del polimorfismo è:
- ridurre il numero di classi
- **consentire la sostituzione di oggetti in modo intercambiabile** ✅
- impedire l'ereditarietà multipla
- evitare l'uso di costruttori

> Un'interfaccia funzionale in Java:
- può contenere più metodi astratti
- **è utilizzata nelle lambda expressions** ✅
- non può estendere altre interfacce
- non ha scopi pratici

> I generics in Java consentono di:
- evitare l'uso delle classi
- **definire tipi parametrici** ✅
- scrivere metodi statici
- gestire errori a runtime

> Un metodo generico è:
- un metodo che accetta solo tipi primitivi
- un metodo che non può essere sovrascritto
- **un metodo definito con parametri di tipo** ✅
- un metodo che lancia sempre un'eccezione

---
## Accesso ai dati con JDBC e MySQL

### Difficoltà 1

> Quale comando si usa per chiudere una connessione JDBC:
- **close()** ✅
- disconnect()
- stop()
- end()

> Quando è necessario chiudere la connessione al database:
- mai
- subito dopo aver eseguito la query
- **alla fine dell'uso del database** ✅
- prima di aprirla

### Difficoltà 2

> Cos'è JDBC:
- un database
- **una libreria Java per accesso ai database** ✅
- un linguaggio di programmazione
- un sistema operativo

> Qual è lo scopo di ODBC:
- **gestire connessioni a database** ✅
- creare interfacce grafiche
- compilare codice Java
- gestire filesystem

> Quale driver è necessario per collegarsi a MySQL tramite JDBC:
- **JDBC-MySQL driver** ✅
- JDBC-Oracle driver
- JDBC-PostgreSQL driver
- JDBC-SQLite driver

> Quale classe Java permette di eseguire query in JDBC:
- **statement** ✅
- FileReader
- socket
- scanner

> Che cos'è un driver JDBC:
- un dispositivo hardware
- **un software che consente la comunicazione con un database** ✅
- un linguaggio di programmazione
- un protocollo di rete

> Quale di questi è un vantaggio nell'usare JDBC:
- accesso diretto a file di testo
- **indipendenza dal database specifico** ✅
- non serve aprire connessioni
- esecuzione solo su Windows

### Difficoltà 3

> Che cosa si intende per elaborazione dei risultati in JDBC:
- creare tabelle
- gestire le query
- **leggere e manipolare i dati ottenuti** ✅
- scrivere programmi

> Qual è la funzione di ResultSet in JDBC:
- memorizzare dati
- visualizzare immagini
- **memorizzare risultati di una query** ✅
- stampare documenti

---
## Introduzione ai design pattern

### Difficoltà 2

> Da dove nasce il concetto di design pattern:
- dallo sviluppo web
- **dalla progettazione software orientata agli oggetti** ✅
- dalla programmazione funzionale
- dall'ingegneria hardware

> Un design pattern è principalmente:
- un linguaggio di programmazione
- **una soluzione riutilizzabile a un problema comune di progettazione** ✅
- un algoritmo per l'ordinamento
- un framework di sviluppo

> Il catalogo dei pattern è organizzato in categorie quali:
- **creazionali, strutturali e comportamentali** ✅
- frontend e backend
- hardware e software
- classi e oggetti

> L'organizzazione del catalogo facilita:
- la scrittura del codice
- **la consultazione e la scelta dei pattern** ✅
- la gestione della memoria
- la compilazione dei programmi

> I design pattern migliorano la progettazione software attraverso:
- **soluzioni testate e riutilizzabili** ✅
- l'uso di linguaggi specifici
- l'eliminazione di bug
- l'ottimizzazione del codice macchina

### Difficoltà 3

> Quale tra i seguenti è un pattern creazionale:
- **Singleton** ✅
- Adapter
- Observer
- Decorator

> Il pattern Adapter serve a:
- modificare il comportamento di un oggetto
- **permettere l'interfaccia tra classi incompatibili** ✅
- gestire la creazione di oggetti
- comunicare eventi tra oggetti

> La struttura di un design pattern include:
- solo il nome e la soluzione
- **nome, problema, soluzione e conseguenze** ✅
- solo la descrizione del problema
- nome, codice e esempio pratico

> Un pattern comportamentale si occupa di:
- gestire la creazione degli oggetti
- definire le interfacce
- **gestire le interazioni e le responsabilità tra oggetti** ✅
- definire la struttura delle classi

> Il pattern Singleton garantisce:
- **la creazione di una sola istanza di una classe** ✅
- la comunicazione tra oggetti
- l'ereditarietà multipla
- l'astrazione totale