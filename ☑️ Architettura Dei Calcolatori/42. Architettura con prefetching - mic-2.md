# 42 Architettura con prefetching mic-2

mic-1 fa passare tutte le operazioni per la ALU, sovraccaricandola, infatti si occupa di:
- fare calcoli veri come and or add ecc...
- incrementare pc
- assemblare operandi

l obiettivo è quindi lasciare la ALU libera di fare solo calcoli e distribuire le responsabilita a piu componenti specifici

## Soluzione: IFU

Instruction Fetch Unit

lavora in parallelo con la ALU e si occupa specificatamente di:
- prefetching -> leggere in anticipo le future istruzioni
- incremento del PC -> incrementa il program counter internamente, non disturbando la ALU
- gestione della coda -> mantiene una coda di istruzioni pronte all uso da caricare istant

### Nuovi Registri

- MBR1 -> 8 bit contiene _opcode_ istruzione successiva
- MBR2 -> 16 bit contiene _operandi_ (se presenti)

## Prefetching

Come funziona?
1. IFU legge continuamente dalla ram caricando MBR1 e MBR2 precaricando la prossima istruzione
2. quando la CPU ha bisogno dell istruzione la chiede alla IFU e la IFU man mano passa i dati facendoli scorrere nei suoi registri fino alla CPU:
    - MBR2 -> MBR1 -> CPU
3. IFU aggiorna PC in automatico in base al numero di byte che passano

Risultato: il ciclo principale _Main1_ scompare poiche completamente gestito in parallelo.

### Esempio con IADD

4 cicli:
...
...
MDR = TOS = MDR + H; wr; goto Main1
Main1 ...

main1 li è necessario perche bisogna preparare il terreno per la prossima istruzione

Mic-2:

3 cicli

1. MAR = SP = SP - 1; rd
2. H = TOS
3. MDR = TOS = MDR + H; wr; goto MBR1

siccome IFU lavora in background ha gia preparato il terreno e non servono ulteriori cicli di clock

