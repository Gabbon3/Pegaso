# 34. BUS

pin della cpu:
1. pin __indirizzi__ -> se hai $m$ pin puoi indirizzare $2^m$ locazioni
2. pin __dati__ -> es 32 quindi parole da 32 bit, piu sono piu costa
3. pin __controllo__ -> sono i vigili urbani, gestiscono il flusso, clock, interrupt e arbitraggio

## Architettura dei bus da unico a multiplo

prima unico bus tutto fare

ad oggi invece la CPU ha almeno 2 bus:
1. memoria -> ha un bus dedicato alla memoria (super veloce)
2. periferiche -> per gestire direttamente i segnali esterni piu lenti (dischi, i/o...)

## Master Slave - chi comanda?

- Master -> chi comanda, la cpu quasi sempre master
- Slave -> chi risponde, non prende mai iniziative
    - la RAM è sempre slave, riceve ordini e basta.
- Caso Speciale -> un controller disco (normalmente slave) puo diventare Master quando si usa il __DMA__ (direct memory access) per scaricare dati direttamente in RAM senza passare dalla CPU. In quel momento, il controller del disco diventa Master e comanda la RAM (slave).

## Bus

### Multiplexato

per risparmiare pin utilizzi le stesse linee per inviare indirizzo e dati ma è piu lento

### Sincrono

tutto succede nei cicli di clock.
se la memoria è piu lenta della cpu? utilizzi segnale $WAIT$

### Asincrono

no clock, utilizza __Full Handshake__

ecco i segnali che utilizza:
1. __MSYN__ (Master Syncronization) -> il master invia
2. __SSYN__ (Slave Syncronization) -> lo slave risponde
3. Master vede SSYN -> toglie MSYN
4. Slave vede MSYN rimosso -> toglie SSYN

## Arbitraggio

il traffico dati, come evitare incidenti:

### Centralizzato

Anche detto __Daisy Chaining__, tutti i dispositivi sono connessi a catena, il segnale passa ognuno di essi con un segnale di _Concessione_, quando arriva al dispositivo corretto il segnale viene bloccato e inizia la comunicazione

Problema: i dispositivi piu vicini hanno priorita assoluta, quelli in fondo potrebbero non parlare mai

### Decentralizzato

Si usano __3 linee condivise__:
1. __Richiesta__ -> wired-or basta che un dispositivo lo attivi
2. __Occupato__ -> chi sta usando il bus lo attiva bloccando gli altri
3. __Arbitraggio In/Out__ -> una linea daisy chain che passa tutti a 5V
- Come funziona -> se vuoi il bus verifichi _Busy_.
    - Se libero e il tuo segnale arbitraggio IN è alto -> prendi il BUS, attivi _Busy_ e neghi arbitraggio OUT

### Operazioni Speciali Block & RMW

1. __Trasferimento a Blocchi__ -> invece di dire _indirizzo -> parola, indirizzo -> parola_ dai l indirizzo 1 volta e leggi piu parole consecutive
2. __leggi-modifica-scrivi__ (RMW):
    - _Problema_ -> due CPU leggono una variabile ("disponibile"), la trovano libera e provano a scriverci contemporaneamente (Race Condition)
    - _Soluzione_ -> questo ciclo speciale permette di leggere, modificare e riscrivere senza mai mollare il bus, in pratica effettua un operazione __atomica__

### Interrupt e 8259A

Interrupt - INT : segnale che sospende temporaneamente l'esecuzione di un programma per permettere alla CPU di gestire un evento prioritario

8259A sarebbe il chip di intel che si occupa di gestire gli interrupt.
- Sequenza:
    1. la periferica attiva una linea IRQ (es la tastiera)
    2. il chip attiva __INT__ verso la CPU
    3. CPU risponde con __INTA__ (interrupt acknowledge)
    4. il chip mette sul bus dati il __numero del vettore__ di interrupt per dire alla cPU quale software lanciare