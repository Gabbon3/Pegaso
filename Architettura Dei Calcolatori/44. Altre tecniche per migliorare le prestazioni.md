# 44. Altre tecniche per migliorare le prestazioni

La CPU per ottimizzare ulteriolmente cerca di indovinare il futuro e cambiare l ordine delle cose:

## 1. Il Problema: La Pipeline odia i "Forse" (predizione dei salti)

le CPU moderne usano __pipeline__. appena pero incontri un branch (if, while, for) ci sono i salti che:
- non permette alla CPU di capire il prossimo salto da fare finche l'istruzione non è completata (esempio _BNE_ branch not equal)
- _lo stallo_ -> la cpu attende e spreca cicli di clock preziosi in attesa di queste casistiche qui

__Soluzione__: fare __Branch Prediction__. Invece di fermarsi e attendere tenta di indovinare dove andra il codice.

### Strategie

__Statica__ semplice:
- salti all'_indietro_ -> nei casi dei cicli for o while, si assume SEMPRE che debba saltare all indietro, questo perche i while o i for si ripetono spesso.
- salti in _avanti_ -> si assume che NON vengano presi questo perche sono spesso eccezioni rare.
- se sbaglia? -> deve buttare via tutto e ripristinare lo stato precedente, facendo _flush_ della pipeline.

## 2. il Ribelle: esecuzione fuori sequenza (out of order)

normalmente le istruzioni vengono eseguite nell'ordine esatto in cui le hai scritte MA:
- se istruzione A è lenta (es. deve leggere da RAM) e B deve attendere A allora B si blocca.
- con l esecuzione in ordine si blocca tutto a cascata.

__soluzione__: la CPU va avanti nella coda ed esegue le istruzioni indipendenti.

__scoreboard__: per non creare caos è stata inventata la scoreboard, un componente hardware dedicato al:
- monitoraggio dei registri e unita di calcolo
- da il via libera a un istruzione solo se non ci sono vincoli pericolosi come:
    - RAW -> read after write - istruzione vincolata da calcolo precedente
    - WAR -> write after read
    - WAW -> write after write - entrambe si riferiscono a casistiche come lettura mentre uno sovrascrive o scrittura concorrente, race conditions.

NOTA: questo rende gli interrupt "imprecisi" poiche l'istruzione 2 potrebbe finire prima dell istruzione 1 compicando debug.

## 3. Lo scommettitore: Esecuzione Speculativa

Non solo si cambia l ordine ma si esegue codice che forse non dovrebbe essere eseguito.

ad esempio per una if che se true fa un calcolo, noi calcoliamo gia quel calcolo:
- vantaggio -> se true allora avremo gia il dato
- svantaggio -> se false avremmo fatto calcoli inutilmente e sprecato registri

__Soluzione__: `SPECULATIVE-LOAD` le CPU moderne hanno questa speciale istruzione che "Prova a caricare questo dato":
- se ce in cache -> usalo
- se non ce -> non importa, non si usa e quindi non blocchiamo l esecuzione. se poi serviva verrà caricato in seguito

