# 43. Miglioramento delle Prestazioni

Collo di bottiglia principale: RAM

Soluzione -> __Gerarchia memorie__

## 1. Gerarchia delle Cache

- L1 -> dentro il chip della CPU. Piccolissima 16-64 KB
    - Peculiarità: è __separata__. Esiste una L1 per le _istruzioni_ e una L1 per i _dati_. In questo modo la CPU puo leggere contemporaneamente istruzioni e dati
- L2 -> vicina alla CPU. 512 KB - 1 MB. Generalmente unificata (mischia dati e istruzioni).
- L3 -> sulla scheda madre o sul processore multicore, ancora piu grande e lenta.

## 2. Come funziona l'indirizzamento

In che modo la CPU capisce dove si trova il dato?

Nelle __Cache a corrispondenza diretta__ ogni indirizzo di memoria ha un solo posto possibile.
L'indirizzo di memoria viene diviso in 3 parti:
1. TAG -> id univoco del blocco di memoria
2. LINE -> indice riga della cache
3. WORD -> seleziona la parola specifica dentro la linea

Come funziona effettivamente?
1. CPU usa _LINE_ per andare alla riga
2. Controlla se il bit _VALID_ è 1
3. Confronta il _TAG_ memorizzato con il _TAG_ dell'indirizzo che cerca
    - TAGi == TAGc -> __HIT__
    - TAGi != TAGc -> __MISS__ non ce e va in RAM

__Problema delle collisioni__: se due variabili condividono la stessa LINE si pesteranno i piedi a vicenda.

## 3. Soluzione Cache Set-Associative

Per evitare le collisioni quindi si utilizzano le cache __Set-Associative__ (Insieme-Associativa). Invece di avere 1 posto per ogni indice ne hai N:
- quando la posizione principale è occupata usi quella di riserva nello stesso set
- quando il set è pieno devi ripulire qualcosa, utilizzi quindi __LRU__ (Least Recently used) rimuovendo il usato meno di recente

## 4. Scrittura in memoria

Quando la CPU modifica un dato nella cache, la RAM non è aggiornata:
1. __Write Through__ -> scrivi subito sia in cache sia in RAM. Sicuro ma _lento_
2. __Write Back__ -> scrivi solo in cache. Aggiorni RAM solo quando la riga viene cancellata da Cache
