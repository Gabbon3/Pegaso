# 50. Java

## Database ODBC - JDBC

### 55. ODBC - Open DataBase Connectivity

- Standard api microsoft dal 92
- Indipendente -> funziona con qualsiasi db
- come funziona ->
    - app invia comandi sql
    - driver odbc traduce i comandi per il db specifico
    - db restituisce dati
- vantaggi ->
    - interoperabilita tra db e app
    - accesso a piu db con un interfaccia

### JDBC - Java DataBase Connectivity

- come funziona ->
    - app java invia comandi sql via jdbc
    - il driver comunica con il db
    - risultati tornano
- vantaggi ->
    - integrato in java compatibile con maggior parte di DBMS (mysql, postgressql, oracle)
    - permette operazioni CRUD

#### Concetti Chiave

- interfaccia per db relazionale:
    - permette codice java indipendente per il db
    - gestisce righe tabelle e colonne come se fossero oggetti java.
- Driver JDBC

### MySQL

Load JDBC driver:
```java
Class.forName("com.mysql.jdbc.Driver").new Instance();
```

Make connection:
```java
Connection conn = DriverManager.getConnection(url);
```

URL:
```java
jdbc:mysql://localhost/mydb?user=USER&password=PASSWORD
```

Interrogare il DB:

creare lo statement:
```java
Statement stmt = conn.CreateStatement();
```

l oggetto stmt invia i comandi tramite:
- `executeQuery()` per SELECT
- `executeUpdate()` per INSERT, UPDATE, DELETE

quindi:
```java
ResultSet rs = stmt.executeQuery("select * from users");
// scorri ogni riga con
rs.next();
// ottieni i valori di riga
String userId = rs.getString("userid");
String type = rs.getInt("type"); // tipo di utente
// di solito si usa while finche esiste una riga
/*
Per inserire o fare update basta usare:
*/
int rows = stmt.executeUpdate("...");
// restituisce il numero di righe intaccate
/*
Alla fine bisogna sempre chiudere la connessione
*/
// chiudo oggetto result set
rs.close();
// chiusura statement
stmt.close();
// chiusura connessione db
conn.close();
```

## 56. Design Patterns

### Catalogo e Classificazione dei Design Pattern (GoF)

Basato sul testo *Design Patterns: Elements of Reusable Object-Oriented Software* (Gamma, Helm, Johnson, Vlissides).

---

#### 1. Definizione
> "Ogni pattern descrive un problema che si ripete più e più volte nel nostro ambiente, descrive poi il nucleo della soluzione del problema, in modo tale che si possa usare la soluzione un milione di volte, senza mai applicarla nella medesima maniera." — **Christopher Alexander**.

---

#### 2. Classificazione per Scopo (Purpose)
I pattern sono suddivisi in tre famiglie principali in base al tipo di problema che risolvono.

##### A. Pattern Creazionali (Creational)
**Obiettivo:** Astrarre il processo di istanziazione. Rendono il sistema indipendente da come gli oggetti vengono creati, composti e rappresentati.

* **Abstract Factory**: Fornisce un'interfaccia per creare famiglie di oggetti correlati o dipendenti senza specificare le classi concrete.
* **Builder**: Separa la costruzione di un oggetto complesso dalla sua rappresentazione, permettendo di creare diverse rappresentazioni dello stesso processo.
* **Factory Method**: Definisce un'interfaccia per la creazione di un oggetto, ma lascia alle sottoclassi la decisione su quale classe istanziare.
* **Prototype**: Specifica i tipi di oggetti da creare usando un'istanza prototipale e crea nuovi oggetti copiando questo prototipo.
* **Singleton**: Garantisce che una classe abbia una sola istanza e fornisce un punto di accesso globale ad essa.

##### B. Pattern Strutturali (Structural)
**Obiettivo:** Gestire la composizione di classi e oggetti per formare strutture più grandi e complesse.

* **Adapter**: Converte l'interfaccia di una classe in un'altra interfaccia attesa dal client. Permette la collaborazione tra classi con interfacce incompatibili.
* **Bridge**: Disaccoppia un'astrazione dalla sua implementazione in modo che le due possano variare indipendentemente.
* **Composite**: Compone oggetti in strutture ad albero per rappresentare gerarchie "parte-tutto". Permette di trattare oggetti singoli e composizioni in modo uniforme.
* **Decorator**: Aggiunge responsabilità addizionali a un oggetto dinamicamente. Offre un'alternativa flessibile all'ereditarietà per estendere le funzionalità.
* **Facade**: Fornisce un'interfaccia unificata e semplificata per un insieme di interfacce in un sottosistema, rendendolo più facile da usare.
* **Flyweight**: Usa la condivisione per supportare efficientemente un gran numero di oggetti a granularità fine (risparmio di memoria).
* **Proxy**: Fornisce un surrogato o un segnaposto per un altro oggetto per controllarne l'accesso.

##### C. Pattern Comportamentali (Behavioral)
**Obiettivo:** Gestire gli algoritmi e l'assegnazione di responsabilità tra oggetti. Descrivono non solo i pattern di oggetti o classi, ma anche i pattern di comunicazione tra di essi.

* **Chain of Responsibility**: Evita l'accoppiamento tra mittente e destinatario di una richiesta, dando a più oggetti la possibilità di gestirla passando la richiesta lungo una catena.
* **Command**: Incapsula una richiesta come un oggetto, permettendo di parametrizzare i client con richieste diverse, accodare o registrare richieste e supportare operazioni annullabili.
* **Interpreter**: Dato un linguaggio, definisce una rappresentazione della sua grammatica e un interprete che usa la rappresentazione per interpretare frasi del linguaggio.
* **Iterator**: Fornisce un modo per accedere sequenzialmente agli elementi di un oggetto aggregato senza esporne la rappresentazione interna.
* **Mediator**: Definisce un oggetto che incapsula le modalità di interazione di un insieme di oggetti. Promuove il disaccoppiamento evitando che gli oggetti si riferiscano esplicitamente l'uno all'altro.
* **Memento**: Senza violare l'incapsulamento, cattura ed esterna lo stato interno di un oggetto in modo che possa essere ripristinato a questo stato in seguito.
* **Observer**: Definisce una dipendenza uno-a-molti tra oggetti in modo che quando un oggetto cambia stato, tutti i suoi dipendenti vengono notificati e aggiornati automaticamente.
* **State**: Permette a un oggetto di alterare il suo comportamento quando il suo stato interno cambia. L'oggetto sembrerà aver cambiato classe.
* **Strategy**: Definisce una famiglia di algoritmi, li incapsula e li rende intercambiabili. Permette all'algoritmo di variare indipendentemente dai client che lo utilizzano.
* **Template Method**: Definisce lo scheletro di un algoritmo in un'operazione, deferendo alcuni passi alle sottoclassi. Permette alle sottoclassi di ridefinire certi passi di un algoritmo senza cambiarne la struttura.
* **Visitor**: Rappresenta un'operazione da eseguire sugli elementi di una struttura di oggetti. Permette di definire una nuova operazione senza cambiare le classi degli elementi su cui opera.

---

#### 3. Classificazione per Raggio d'Azione (Scope)
Oltre allo scopo, i pattern si distinguono in base a se si applicano principalmente alle **Classi** (statico, ereditarietà) o agli **Oggetti** (dinamico, composizione).

| Raggio d'Azione | Creazionale | Strutturale | Comportamentale |
| :--- | :--- | :--- | :--- |
| **Classe** (Compile-time) | Factory Method | Adapter (di classe) | Interpreter, Template Method |
| **Oggetto** (Run-time) | Abstract Factory, Builder, Prototype, Singleton | Adapter (di oggetto), Bridge, Composite, Decorator, Facade, Flyweight, Proxy | Chain of Responsibility, Command, Iterator, Mediator, Memento, Observer, State, Strategy, Visitor |

*Tabella basata sulla classificazione descritta a pagina 17 del PDF.*

## 57. Caso studio design pattern Composite e Strategy